<div id="назначение-star" class="section level3" number="0.0.1">
<h3><span class="header-section-number">0.0.1</span> Назначение STAR</h3>
<p>Процесс выравнивания отсеквенированных последовательностей состоит из
выбора подходящего эталонного генома для картирования полученных
прочтений и выравнивания прочтений с использованием одного из нескольких
инструментов. В отличие от других ChIP-seq или секвенирования генома,
прочтения RNA-seq содержат сплайсированные последовательности. Это
означает, что прямое сопоставление прочтений с референсом путем
выравнивания ридов по всей длине сделает невозможным картирование
большинства фрагментов. Это свойство транскриптов учитывается
несколькими элайнерами, среди которых наиболее популярны
<a href="https://academic.oup.com/bioinformatics/article/29/1/15/272537">STAR</a>,
<a href="https://daehwankimlab.github.io/hisat2/">HISAT2</a> или
<a href="https://ccb.jhu.edu/software/tophat/manual.shtml">TopHat</a>. Выбор
элайнера часто является личным предпочтением, а также зависит от
доступных вам вычислительных ресурсов.</p>
{{% notice "info" %}}
STAR стал популярным по нескольким причинам. Во-первых, это один из самых быстрых элайнеров. Во-вторых, точность выравнивания с помощью STAR в ряде тестов превышает конкурентов (не всегда). Пожалуй, по производительности он может уступать только Hisat2 (и то не всегда). Однако в отличие от Hisat2 он предоставляет подробный отчет о положении сайтов-сплайсинга, может сразу подсчитывать число прочтений в транскриптах, сразу строит профиль покрытия генома прочтениями, делает анализ нуклеотидных вариантов в прочтениях, оптимизирован для анализа single cell RNA-seq и пр. Его ключевым недостатком является высокая требовательность к оперативной памяти. В тестах его требования к памяти превышают таковые у Hisat2 в 5-10 раз (20-40 Gb оперативной памяти при анализе генома человека).
{{% /notice %}}
</div>
<div id="описание-алгоритма" class="section level3" number="0.0.2">
<h3><span class="header-section-number">0.0.2</span> Описание алгоритма</h3>
<p>Большинство популярных инструментов выравнивания ридов RNA-seq были
разработаны как усовершенствованные версии программ выравнивания
непрерывных коротких последовательностей ДНК (<strong>bowtie</strong>, <strong>bwa</strong> и пр.)
и основаны либо на выравнивания коротких прочтений по базеэкзон-экзонных
стыков <em>(splice junctions)</em>, либо на выравнивании сегментов рида на
непрерывную последовательность эталонного генома, либо на комбинации
двух подходов. В отличие от них STAR был разработан для выравнивания
сплайсированных последовательностей непосредственно на эталонный
геномом. Алгоритм STAR состоит из двух основных этапов: этап поиска
зерновых последовательностей <em>(seed)</em> и этап
кластеризации/сшивки/скоринга <em>(clustering/stitching/scoring)</em>.</p>
{{% expand "Развернутое описание" %}}
<p>Центральной идеей этапа поиска зерновых последовательностей STAR
является последовательная процедура поиска максимального картируемого
префикса <em>(Maximal Mappable Prefix, MMP)</em>. Говоря математическим языком,
если обозначить последовательность рида как R, номер нуклеотида внутри
рида как i, а эталонную последовательность генома за G, то функция
MMP(R,i,G) вернет самую длинную подстроку (Ri, Ri+1, … , Ri+MML- 1),
которая точно совпадает с одной или несколькими подстроками G, где MML
– это максимальная картируемая длина. На первом этапе алгоритм находит
MMP начиная с первого нуклеотида в риде. Риды, которые содержат
экзон-экзонный стык, не могут быть выравнены на референсный геном всей
длиной. Однако благодаря алгоритму MMP первое зерно будет
соответствовать донорскому сайту сплайсинга. Далее поиск MMP
повторяется, но уже для оставшейся непрокартированной части рида,
которая в данном случае будет выравнена на акцепторный сайт сплайсинга.
Последовательное применение MMP-поиска только к некартированным участкам
рида делает алгоритм STAR чрезвычайно быстрым. Поиск MMP в STAR
реализуется через алгоритм несжатых <em>(Uncompressed)</em> суффиксных деревьев
<em>(Suffix Arrays, SA)</em>. Примечательно, что поиск MMP является
неотъемлемым результатом стандартного бинарного поиска строк в несжатых
SA и не требует дополнительных вычислительных усилий по сравнению с
полноразмерным поиском точного соответствия. Бинарная природа поиска в
SA приводит к тому, что время поиска оказывается связано с длиной
эталонного генома логарифмически, что обеспечивает быстрый поиск даже в
больших геномах. Преимуществом является то, что для каждого MMP поиск SA
может найти все отдельные точные геномные совпадения с небольшими
вычислительными затратами, что облегчает точное выравнивание ридов,
которые сопоставляются с несколькими геномными локусами <em>(multipammed
reads)</em>.</p>
<p><img src="/Programs/STAR.files/fig1.png?width=40pc" /></p>
<p>Помимо обнаружения сплайс-cайтов, поиск MMP позволяет находить
множественные несоответствия и инделы. Если поиск MMP не достигает конца
рида из-за наличия одного или нескольких несоответствий, MMP служат
якорями внутри рида, которые можно расширять на референс, что делает
возможным выравнивание ридов с ошибками. В некоторых случаях процедура
расширения выравниваний <em>(extension)</em> не дает хорошего результата, что
позволяет идентифицировать поли-А хвосты, последовательности
библиотечных адаптеров или хвосты ридов с низким качеством
секвенирования. Поиск MMP осуществляется как в прямом, так и в обратном
направлении последовательности рида и может быть начат с заданных
пользователем точек начала поиска по всей длине рида, что облегчает
поиск якорей для ошибочных последовательностей на концах ридов и
повышает чувствительность картирования в условиях высокой частоты ошибок
секвенирования.</p>
<p>Помимо эффективного алгоритма поиска MMP, несжатые SA также
демонстрируют значительное преимущество в скорости по сравнению со
сжатыми SA, реализованными во многих популярных выравнивателях коротких
ридов. Однако высокая скорость компенсируется увеличенной
требовательностью к памяти.</p>
<p>На втором этапе алгоритма STAR строит выравнивание всей
последовательности чтений путем сшивания всех затравочных подстрок,
которые были выровнены по геному на первом этапе. Сначала затравки
объединяются в кластеры по расстоянию от выбранномого набора “якорных”
затравок. Оптимальной процедурой для выбора якорей является ограничение
числа геномных локусов, с которыми выравниваются якоря. Все затравочные
подстроки, которые картируютс в заданных пользователем геномных окнах
вокруг якорей, сшиваются вместе с использованием локальной линейной
модели транскрипции. Размер геномных окон определяет максимальный размер
интрона для сплайсированных выравниваний. Для сшивания каждой пары
затравочных выравниваний используется щадящий алгоритм динамического
программирования, допускающий любое количество несовпадений, но только
одну вставку или делецию <em>(gap)</em>.</p>
<p>Важно отметить, что затравки из парных прочтений RNA-seq кластеризуются
и сшиваются одновременно, при этом спаренные риды представлены как
разные последовательности, что допускает возможный геномный интервал или
перекрытие между внутренними концами парных ридов. Это принципиальный
способ использования информации о парных концах лучше отражает природу
парных прочтений, а именно тот факт, что пары представляют собой части
(концы) одного и того же фрагмента ДНК. Такой подход повышает
чувствительность алгоритма, так как для точного выравнивания всего
прочтения достаточно одного правильного якоря от одного из ридов.</p>
<p>Если выравнивание в пределах одного геномного окна не покрывает всю
последовательность рида (парных ридов), STAR попытается найти два или
более окон, которые покрывают весь рид (оба рида), что приводит к
химерному выравниванию, при котором разные части рида (ридов)
отображаются на дистальные геномные локусы, или разные хромосомы, или
разные нити. STAR может найти химерные выравнивания, в которых пары
ридов являются химерными друг для друга, с химерным соединением,
расположенным в неотсеквенированной части молекулы РНК. STAR также может
найти химерные выравнивания, в которых один или оба спаренных рида имеют
внутреннее химерное выравнивание, что позволяет точно определить
местоположение химерного соединения в геноме.</p>
<p>Скоринг осуществляется с помощью локальной схемы оценки выравнивания с
заданными пользователем баллами (штрафами) за совпадения, несовпадения,
вставки, удаления и разрывы сплайс-соединений, что позволяет
количественно оценить качество и ранг выравнивания. Комбинация сшивок с
наивысшим баллом выбирается в качестве наилучшего выравнивания ридов.
Для ридов с множественными выравниваниями сообщается обо всех
выравниваниях с оценками в пределах определенного пользователем
диапазона ниже наивысшей оценки.</p>
<p>Хотя последовательный поиск MMP находит только затравочные подстроки,
точно соответствующие геному, последующая процедура сшивки способна
выравнивать чтения с большим количеством несовпадений, инделов и
сплайс-соединений с масштабированием на длину рида.</p>
{{% /expand %}}
</div>
<div id="установка" class="section level3" number="0.0.3">
<h3><span class="header-section-number">0.0.3</span> Установка</h3>
<pre><code>conda install -c bioconda star</code></pre>
{{% notice "warning" %}}
Установка возможна только на Linux или OSX. Можно также попробовать запустить на Windows через Docker-клиент. Однако есть большая веротность, что ноутбук не справится с запуском программы из-за высоких требований к оперативной памяти.
{{% /notice %}}
</div>
<div id="основные-этапы-анализа-при-помощи-star" class="section level3" number="0.0.4">
<h3><span class="header-section-number">0.0.4</span> Основные этапы анализа при помощи STAR</h3>
<p>Как и в случае с другими элайнерами, выравнивание прочтений с помощью
STAR — это двухэтапный процесс:</p>
<ol style="list-style-type: decimal">
<li>Создание индекса на основе референсного генома.</li>
</ol>
{{% notice "info" %}}
Индекс - это сжатая версия текстовой последовательности генома. Фаловая структура индекса оптимизирована для быстрого поиска подпоследовательностей ДНК в геноме при помощи алгоритмов динамического программирования. Индекс создается один раз в папке назначения, и дальше используется неограниченное число раз для выравнивания ридов. Готовые индексы можно скачивать из интернета.
{{% /notice %}}
<ol start="2" style="list-style-type: decimal">
<li>Картирование прочтений на геном.</li>
</ol>
{{% notice "info" %}}
На этом этапе пользователь предоставляет папку с геномным индексом, а также файлы с прочтениями (последовательности) RNA-seq в формате FASTA или FASTQ. STAR сопоставляет прочтения с геномом и записывает несколько выходных файлов, включая выравнивание (SAM/BAM), сводную статистику, координаты экзон-экзонных стыков, невыравненные прочтения, профиль покрытия (wiggle) и т.д.
{{% /notice %}}
</div>
<div id="работа-со-star-в-командной-строке" class="section level3" number="0.0.5">
<h3><span class="header-section-number">0.0.5</span> Работа со STAR в командной строке</h3>
<p>Запуск программы STAR происходит при помощи интерфейса командной строки.
Программа запускается одной командой <code>STAR</code>, а режим работы (индексация
генома, выравнивание и пр.) определяется обязательным параметром
<code>--runMode</code>. Есть также версия программы <code>STARlong</code>, предназначенная,
по-видимому, для выравнивания длинных прочтений. У нее практически те же
самые параметры, что и у <code>STAR</code>, только добавлены параметры</p>
<div id="индексация-генома" class="section level5" number="0.0.5.0.1">
<h5><span class="header-section-number">0.0.5.0.1</span> Индексация генома</h5>
<p>Для создания индекса программе нужен: 1. fasta-файл (или несколько
файлов, указанных списком через пробел) с референсным геномом. 2.
[опционально] gtf-файл с координатами генов/транскриптов. STAR извлечет
из этого файла координаты экзон-экзонных стыков (сплайс-сайтов) и
использует их для значительного повышения точности картирования. Этот
файл необязателен, и STAR можно запускать без аннотаций. В то же время,
использование аннотаций настоятельно рекомендуется создателями программы
всегда, когда они доступны. Начиная с версии 2.4.1a, аннотации также
могут быть включены “на лету” на этапе картирования.</p>
{{% notice "info" %}}
Индексированный геном включает двоичную последовательность генома, деревья суффиксов, текстовые названия/длины хромосом, координаты сплайс-сайтов и информацию о транскриптах/генах. Большинство этих файлов используют внутренний формат STAR и не предназначены для использования конечным пользователем.  Настоятельно не рекомендуется изменять любой из этих файлов, за одним исключением: вы можете переименовать имена хромосом в файле chrName.txt, сохранив порядок хромосом в этом файле. Имена хромосом из этого файла будут использоваться во всех выходных файлах (например, SAM/BAM).
{{% /notice %}}
<p>Основные параметры для создания индексированного генома с использованием
STAR следующие:</p>
<ul>
<li><code>--runThreadN число_потоков</code> устанавливает многопоточный режим</li>
<li><code>--runMode genomeGenerate</code> указывает программе, что она должна
создать индексированный геном</li>
<li><code>--genomeDir /путь/к/папке/для/хранения/индексов</code></li>
<li><code>--genomeFastaFiles /путь/к/FASTA1 /путь/к/FASTA2 ...</code></li>
<li><code>--sjdbGTFfile /путь/к/GTF</code></li>
<li><code>--sjdbOverhang длина_рида-1</code> используется программой для построения
базы аннотированных экзонных стыков. Если величина равна 100, то
STAR будет индексировать последовательности длиной 100 пар с каждой
стороны от сайта сплайсинга. В идеале эта величина должна составлять
длину рида минус 1. Например, для запуска в режиме 2x150 bp
(спаренные риды длиной 150 пар), идеальным значением будет
150-1=149. В случае, если риды имеют разную длину, то лучше выбрать
длину самого протяженного рида и отнять единицу. Если этот параметр
не указать, то программа воспользуется значением 100. Это значение
отлично подходит в большинстве случаев.</li>
</ul>
{{% notice "tip" %}}
По логике вещей, параметр --sjdbOverhang вообще может быть сколько угодно больше длины рида. Так что если вы индексировали геном с параметром 149, а реальная длина ридов 75, то на результат это никак не повлияет. Единственное, чем он больше, тем больше памяти занимает индекс. Вообще же, если вы не предоставляете gtf-файл с аннотацией генома, то на этот параметр можно не обращать внимания, ибо он ни на что не повлияет.
{{% /notice %}}
{{% expand "Расширенные параметры" %}}
<ul>
<li><em>Аннотация генома в GFF-формате</em></li>
</ul>
<p>STAR может принимать аннотацию в формате
<a href="https://learn.gencore.bio.nyu.edu/ngs-file-formats/gff3-format/#:~:text=General%20Feature%20Format%20(GFF)%20is,be%20handled%20by%20this%20format.">GFF3</a>.
В таком случае такой файл нужно привести после параметра
<code>--sjdbGTFfile</code>, и заодно указать параметр
<code>--sjdbGTFtagExonParentTranscript Parent</code>. По умолчанию STAR ищет в
каждой строке файла аннотации фрагмент текста, начинающийся с
“transcript_id=”. В формате GFF такой записи нет, вместо нее
используется “Parent=”. Поскольку задачей STAR является поиск
аннотированных экзон-экзонных стыков, во время процессинга GTF/GFF
файлов он будет искать только строки, в которых 3й столбец содержит
слово “exon”. Это поведение задается параметром по умолчанию
<code>--sjdbGTFfeatureExon exon</code>.</p>
<ul>
<li><em>Лист аннотированных экзон-экзонных стыков</em></li>
</ul>
<p>STAR может принять для аннотации список экзон-экзонных стыков. Для этого
необходимо подготовить отформатированную табулированную таблицу (без
заголовков):</p>
<pre><code>Chr   Start   End   Strand</code></pre>
<p>Start и End - это координаты первого и последнего нуклеотида в интроне
(в системе координат <strong>1-base</strong>, где первый нуклеотид на хромосоме имеет
координату 1). Strand - это “+”, “-” или “.”. Этот файл может иметь
дупликаты, STAR сам их удалит.</p>
<p>Привести этот файл нужно после параметра
<code>--sjdbFileChrStartEnd /путь/к/координатам_стыков</code></p>
<p>Этот файл можно использовать как дополнение к GTF-файлу с аннотацией, а
можно и без него. STAR сам разберется.</p>
<ul>
<li><em>Работа с короткими геномами</em></li>
</ul>
<p>Если размер генома <em>L</em> меньше 1 Gb, то параметр <code>--genomeSAindexNbases</code>
нужно понизить до величины log<sub>2</sub>(<em>L</em>)/2 - 1.</p>
{{% /expand %}}
<ul>
<li><em>Референсы с большим числом хромосом/скэффолдов/контигов</em></li>
</ul>
<p>При работе с FASTA-файлами, в которых большое число последовательностей,
можно понизить требования к оперативной памяти при помощи параметра
<code>--genomeChrBinNbits</code>. Если обозначить длину генома за <em>L</em>, число
последовательностей в референсном геноме за <em>N</em>, а длину рида за <em>l</em>, то
наилучшим значением для этого параметра будет
min(18,log<sub>2</sub>[max(<em>L</em>/<em>N</em>,<em>l</em>)]).</p>
</div>
</div>
<div id="полный-список-параметров" class="section level3" number="0.0.6">
<h3><span class="header-section-number">0.0.6</span> Полный список параметров</h3>
<ul>
<li><em>Файл с параметрами</em></li>
</ul>
<table>
<colgroup>
<col width="28%" />
<col width="21%" />
<col width="49%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по
умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--parametersFiles</code></td>
<td><code>-</code></td>
<td><p><strong>путь к файлу</strong></p>
<p>Путь к файлу со списком заданных параметров
для запуска в командной строке. “-” - путь по
умолчанию, соответсвует
<a href="ht%20tp%20s://git%20hub.com/a%20lexdobin/ST%20AR/b%20l%20ob/master/sourc%20e%20/parametersDefault">файлу</a>
<code>parametersDefault</code> в папке <code>source</code> в
директории с программой STAR</p></td>
</tr>
</tbody>
</table>
<ul>
<li><em>Выбор системной оболочки</em></li>
</ul>
<table>
<colgroup>
<col width="37%" />
<col width="29%" />
<col width="32%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по
умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--sysShell</code></td>
<td><code>-</code></td>
<td><p><strong>путь к бинарному
файлу</strong></p>
<p>Путь к интерпретатору
оболочки в
Unix-системе. “-” -
путь по умолчанию в
системе (обычно
<code>/bin/sh</code> или
<code>/bin/bash</code>).
Указывается только
при возникновении
ошибки в некоторых
системах Linux.</p></td>
</tr>
</tbody>
</table>
<ul>
<li><em>Выбор системной оболочки</em></li>
</ul>
<table>
<colgroup>
<col width="26%" />
<col width="20%" />
<col width="53%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по
умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--runMode</code></td>
<td><code>alignReads</code></td>
<td><p><strong>строка</strong></p>
<p>Определяет режим работы программы:</p>
<p><code>alignReads</code> - картирование прочтений на референс;</p>
<p><code>genomeGenerate</code> - индексирование референса;</p>
<p><code>inputAlignmentsFromBAM</code> - генерирует профиль
покрытия на основе выравненного BAM-файла. Работает
только с параметрами <code>--outWigType</code> и
<code>--bamRemoveDuplicates</code>;</p>
<p><code>liftOver</code> - конвертирует <em>(lift-over)</em> GTF-файл
(заданный параметром <code>--sjdbGTFfile</code>) между версиями
геномных сборок при помощи файла
<code>--genomeChainFiles</code>;</p>
<p><code>soloCellFiltering &lt;папка с пос читанными прочтени ями&gt; &lt;путь для  з аписи отфильтрованных префиксов&gt;</code> -
запускает фильтрацию баркодированных прочтений
scRNA-seq без перевыравнивания при помощи
<strong>STARsolo</strong></p></td>
</tr>
<tr class="even">
<td><code>--runThreadN</code></td>
<td><code>1</code></td>
<td><p><strong>целое число</strong></p>
<p>Число потоков</p></td>
</tr>
<tr class="odd">
<td><code>--runDirPerm</code></td>
<td><code>User_RWX</code></td>
<td><p><strong>строка</strong></p>
<p>Разрешения на запись, чтение, удаление файлов во
время работы программы</p>
<p><code>User_RWX</code> - user-read/write/execute (доступ только
для юзера)</p>
<p><code>All_RWX</code> - all-read/write/execute (аналог chmod 777,
доступ для всех)</p></td>
</tr>
<tr class="even">
<td><code>--runRNGseed</code></td>
<td><code>777</code></td>
<td><p><strong>целое число</strong></p>
<p>Зерно для генератора случайных чисел. Два одинаковых
запуска программы с разным зерном дадут немного
различающиеся результаты.</p></td>
</tr>
</tbody>
</table>
<ul>
<li><em>Параметры генома</em></li>
</ul>
<table>
<colgroup>
<col width="38%" />
<col width="20%" />
<col width="41%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по
умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--genomeDir</code></td>
<td><code>./GenomeDir/</code></td>
<td><p><strong>путь к директории</strong></p>
<p>Путь к директории с
индексированным геномом. В
режиме <code>generateGenome</code> индексы
будут записаны сюда. В режиме
<code>alignReads</code> индексы будут
искаться здесь.</p></td>
</tr>
<tr class="even">
<td><code>--genomeLoad</code></td>
<td><code>N oSharedMemory</code></td>
<td><p><strong>строка</strong></p>
<p>Порядок действий с <a href="https://groups%20.g%20oog%20le.com/g/rna-star/c/_O6jH-D4Rqw">общей
оперативной
па
мятью</a>
при использовании файлов генома.
Общая память позволяет
нескольким запущенным программам
STAR обращаться к одному разделу
памяти, сократив время запуска
программы. Используется только в
режиме <code>alignReads</code>, когда
планируется делать несколько
запусков программы.</p>
<p><code>LoadAndKeep</code> - загрузить геном
в общую память и хранить там
после окочания программы.</p>
<p><code>LoadAndRemove</code> - загрузить
геном в общую память и удалить
после окончания программы</p>
<p><code>LoadAndExit</code> - загрузить в
общую память и сразу выйти.
Хранить в памяти до последующих
запусков.</p>
<p><code>Remove</code> - не картировать
ничего, только удалить
загруженный в память геном</p>
<p><code>NoSharedMemory</code> - не
использовать общую память</p></td>
</tr>
<tr class="odd">
<td><code>--genomeFastaFiles</code></td>
<td><code>-</code></td>
<td><p><strong>адрес файла</strong></p>
<p>Путь к FASTA-файлам с
референсными
последовательностями генома.
<strong>Файлы не могут быть сжатыми.</strong>
Обязательно указывается в режиме
<code>generateGenome</code>. В режиме
<code>alignReads</code> позволяет добавить
дополнительные
последовательности к
индексированному референсному
геному (например spike-in
контроли в RNA-seq)</p></td>
</tr>
<tr class="even">
<td><code>--genomeChainFiles</code></td>
<td><code>-</code></td>
<td><p><strong>адрес файла</strong></p>
<p>Путь к <a href="htt%20ps://genviz.org/modul%20e-%2001-%20intro/0001/06/02/liftoverTools/">.c
hain</a>
файлу для конвертации
<em>(lift-over)</em> GTF между версиями
сборки генома. Используется
только в режиме <code>liftOver</code>.</p></td>
</tr>
<tr class="odd">
<td><code>--genomeFileSizes</code></td>
<td><code>0</code></td>
<td><p><strong>целое число</strong></p>
<p>Точные размеры индексов в
байтах. Не используется юзерами.</p></td>
</tr>
<tr class="even">
<td><code>--genomeTransformOutput</code></td>
<td><code>None</code></td>
<td><p><strong>строка</strong></p>
<p>Используется при картировании
RNA-seq ридов на <em>консенсусный
геном</em> алгоритмом
<strong>STARconsensus</strong>, когда
результирующие координаты
выравниваний или экзонных-стыков
сдвигаются. При необходимости
можно заставить программу
трансформировать результирующие
координаты в исходные,
соотвествующие исходному
референсу.</p>
<p><code>SAM</code> - трансформирует
координаты к изначальным</p></td>
</tr>
<tr class="odd">
<td><code>--genomeChrSetMitochondrial</code></td>
<td><code>chrM M MT</code></td>
<td><p><strong>строка</strong></p>
<p>Названия митохондриальных
хромосом. Испольуется только для
вывода статистики алгоритмом
<strong>STARsolo</strong>.</p></td>
</tr>
</tbody>
</table>
<ul>
<li><em>Параметры индексирования генома в режиме <code>genomeGenerate</code></em></li>
</ul>
<table>
<colgroup>
<col width="39%" />
<col width="21%" />
<col width="39%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по
умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--genomeChrBinNbits</code></td>
<td><code>18</code></td>
<td><p><strong>целое число</strong></p>
<p>При хранении генома каждая
хромосома будет занимать
целое число бинов. Параметр
определяет размер бина
через показательную функцию
log<sub>2</sub>(chrBin). При работе
с геномами, в которых
большое число контигов,
этот параметр нужно
снизить. Если обозначить
длину генома за <em>L</em>, число
последовательностей в
референсном геноме за <em>N</em>,
а длину рида за <em>l</em>, то
наилучшим значением для
этого параметра будет
min(18
,log<sub>2</sub>[max(<em>L</em>/<em>N</em>,<em>l</em>)]).</p></td>
</tr>
<tr class="even">
<td><code>--genomeSAindexNbases</code></td>
<td><code>14</code></td>
<td><p><strong>целое число</strong></p>
<p>Длина преиндексированной
строки в дереве суффиксов
<em>(SA)</em>. Обычно между 10 и
15. Более длинные строки
требуют больше памяти, но
ускоряют поиск. Для
маленьких геномов (меньше
1Gb) должнобыть уменьшено
согласно формуле:</p>
<p>min(14, log<sub>2</sub>(<em>L</em>)/2 - 1),
где <em>L</em> - длина генома.</p></td>
</tr>
<tr class="odd">
<td><code>--genomeSAsparseD</code></td>
<td><code>1</code></td>
<td><p><strong>целое положительное
число</strong></p>
<p>Разряженность <em>(sparsity)</em>
дерева суффиксов, ака
дистанция между
индексированными
суффиксами. Чем больше
число, тем меньше
требования к оперативной
памати, но медленнее
выравнивание.</p></td>
</tr>
<tr class="even">
<td><code>--genomeSuffixLengthMax</code></td>
<td><code>-1</code></td>
<td><p><strong>целое число</strong></p>
<p>максимальная длина
суффиксов. Должна быть
больше длины ридов.
Значение <code>-1</code> означает
бесконечность.</p></td>
</tr>
<tr class="odd">
<td><code>--genomeTransformType</code></td>
<td><code>None</code></td>
<td><p><strong>строка</strong></p>
<p>Тип трансформации генома:</p>
<p><code>None</code> - нет трансформации;</p>
<p><code>Haploid</code> - заменает
референсные аллели
альтернативными вариантами
из VCF-файла (на консенсус)</p>
<p><code>Diploid</code> - создает два
гаплотипа для каждой
хромосомы в VCF-файле.
Предполагает идеальное
фазирование между геномами,
то есть что пары гаплотипов
соответствуют отцу и
матери.</p></td>
</tr>
<tr class="even">
<td><code>--genomeTransformVCF</code></td>
<td><code>-</code></td>
<td><p><strong>путь к файлу</strong></p>
<p>Путь к VCF-файлу для
трансформации генома</p></td>
</tr>
</tbody>
</table>
<ul>
<li><em>Параметры базы экзонных стыков (Splice Junctions)</em></li>
</ul>
<table>
<colgroup>
<col width="35%" />
<col width="22%" />
<col width="42%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--sjdbFileChrStartEnd</code></td>
<td><code>-</code></td>
<td><p><strong>путь к файлу</strong></p>
<p>Путь к файлу с геномными координатами
экзон-экзонных стыков. Может быть несколько
файлов, перечисленных через пробел.</p></td>
</tr>
<tr class="even">
<td><code>--sjdbGTFfile</code></td>
<td><code>-</code></td>
<td><p><strong>путь к файлу</strong></p>
<p>Путь к GTF-файлу с аннотацией генома.</p></td>
</tr>
<tr class="odd">
<td><code>--sjdbGTFchrPrefix</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>префикс в начале имени хромосомы в GTF-файле.
Как правило это <strong>“chr”</strong>. Может пригодиться
при использовании аннотации ENSEMBL и
референса UCSC.</p></td>
</tr>
<tr class="even">
<td><code>--sjdbGTFfeatureExon</code></td>
<td><code>exon</code></td>
<td><p><strong>строка</strong></p>
<p>Тип объекта <em>(feature)</em> в <a href="https://www.e%20ns%20embl%20.org/info/web%20site/upload/gff.html">GT
F-файле</a>,
который будет использоваться в качестве
экзонов при построении транскриптов.</p></td>
</tr>
<tr class="odd">
<td><code>--sjdbGTFtagExonParentTranscript</code></td>
<td><code>transcript_id</code></td>
<td><p><strong>строка</strong></p>
<p>Название атрибута в GTF-файле, который будет
использоваться качестве идентификатора <em>(ID)</em>
порождающего транскрипта <em>(parent
transcript).</em></p></td>
</tr>
<tr class="even">
<td><code>--sjdbGTFtagExonParentGene</code></td>
<td><div class="line-block"><code>gene_id</code><br />
</div></td>
<td><div class="line-block"><strong>строка</strong><br />
</div>
Название атрибута в GTF-файле, который будет
использоваться качестве идентификатора <em>(ID)</em>
порождающего гена <em>(parent gene).</em></td>
</tr>
<tr class="odd">
<td><code>--sjdbGTFtagExonParentGeneName</code></td>
<td><code>gene_name</code></td>
<td><p><strong>строка</strong></p>
<p>Название атрибута в GTF-файле, который будет
использоваться качестве названия <em>(name)</em>
порождающего гена <em>(parent gene).</em></p></td>
</tr>
<tr class="even">
<td><code>--sjdbGTFtagExonParentGeneType</code></td>
<td><code>ge ne_type  gene_biotype</code></td>
<td><p><strong>строка</strong></p>
<p>Название атрибутов в GTF-файле, который будет
использоваться качестве типа
(белок-кодирующий, некодирующий и пр.)
порождающего гена <em>(parent gene type).</em></p></td>
</tr>
<tr class="odd">
<td><code>--sjdbOverhang</code></td>
<td><code>100</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>длина донорской/акцепторной
последовательности с каждой стороны
экзон-экзонного стыка. В идеале должно быть
на 1 короче длины рида.</p></td>
</tr>
<tr class="even">
<td><code>--sjdbScore</code></td>
<td><code>2</code></td>
<td><p><strong>целое число</strong></p>
<p>Дополнительный бонус за выравнивание <em>(extra
alignment score)</em>, которое пересекает базу
экзонных стыков.</p></td>
</tr>
<tr class="odd">
<td><code>--sjdbInsertSave</code></td>
<td><code>Basic</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает, какие файлы сохранять, когда
информация об экзонных стыках добавляется на
стадии выравнивания:</p>
<p><code>Basic</code> - только малые стыки/файлы с
транскриптами</p>
<p><code>All</code> - все файлы, включая дополнительные
файлы индексов. По сути это создаст
измененную копию геномного индекса в папке,
из которой была запущена программа.</p></td>
</tr>
</tbody>
</table>
<ul>
<li>Добавление геномных вариантов</li>
</ul>
<table style="width:88%;">
<colgroup>
<col width="23%" />
<col width="30%" />
<col width="33%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по
умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--varVCFfile</code></td>
<td><code>-</code></td>
<td><p><strong>путь к файлу</strong></p>
<p>Путь к файлу
[VCF]
(http%20s://e%20n.wik
ipedia.org/wi%20k%20i
/Variant_Call_Format)
c данными по вариации
генома. В 10й колонке
должен содержать
информацию о генотипе
в формате 0/1.</p></td>
</tr>
</tbody>
</table>
<ul>
<li><em>Вводные файлы для профиля покрытия</em></li>
</ul>
<table>
<colgroup>
<col width="33%" />
<col width="25%" />
<col width="40%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по
умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--inputBAMfile</code></td>
<td><code>-</code></td>
<td><p><strong>путь к файлу</strong></p>
<p>Путь к файлу BAM-файлу для
построения профилей покрытия
генома в режиме
<code>inputAlignmentsFromBam</code></p></td>
</tr>
</tbody>
</table>
<ul>
<li><em>Параметры базы экзонных стыков (Splice Junctions)</em></li>
</ul>
<table>
<colgroup>
<col width="36%" />
<col width="19%" />
<col width="44%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по
умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--sjdbFileChrStartEnd</code></td>
<td><code>-</code></td>
<td><p><strong>путь к файлу</strong></p>
<p>Путь к файлу с геномными координатами
экзон-экзонных стыков. Может быть несколько файлов,
перечисленных через пробел.</p></td>
</tr>
<tr class="even">
<td><code>--sjdbGTFfile</code></td>
<td><code>-</code></td>
<td><p><strong>путь к файлу</strong></p>
<p>Путь к GTF-файлу с аннотацией генома.</p></td>
</tr>
<tr class="odd">
<td><code>--sjd bGTFchrPrefix</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>префикс в начале имени хромосомы в GTF-файле. Как
правило это <strong>“chr”</strong>. Может пригодиться при
использовании аннотации ENSEMBL и референса UCSC.</p></td>
</tr>
<tr class="even">
<td><code>--sjdbG TFfeatureExon</code></td>
<td><code>exon</code></td>
<td><p><strong>строка</strong></p>
<p><a href="https:%20//www.ensembl.%20org/info/website/upload/gff.html">GTF-файле</a>,
который будет использоваться в качестве экзонов при
построении транскриптов.</p></td>
</tr>
<tr class="odd">
<td><code>--sjd bGTFtagExonParentTranscript</code></td>
<td><code>transcript_id</code></td>
<td><p><strong>строка</strong></p>
<p>Название атрибута в GTF-файле, который будет
использоваться качестве идентификатора <em>(ID)</em>
порождающего транскрипта <em>(parent transcript).</em></p></td>
</tr>
<tr class="even">
<td><code>--sjdbGTFtagExonParentGene</code></td>
<td><code>gene_id</code></td>
<td><p><strong>строка</strong></p>
<p>Название атрибута в GTF-файле, который будет
использоваться качестве идентификатора <em>(ID)</em>
порождающего гена <em>(parent gene).</em></p></td>
</tr>
<tr class="odd">
<td><code>--sjdbGTFtagExonParentGeneName</code></td>
<td><code>gene_name</code></td>
<td><p><strong>строка</strong></p>
<p>Название атрибута в GTF-файле, который будет
использоваться качестве названия <em>(name)</em>
порождающего гена <em>(parent gene).</em></p></td>
</tr>
<tr class="even">
<td><code>--sjdbGTFtagExonParentGeneType</code></td>
<td><code>gen e_type gene_biotype</code></td>
<td><p><strong>строка</strong></p>
<p>Название атрибутов в GTF-файле, который будет
использоваться качестве типа (белок-кодирующий,
некодирующий и пр.) порождающего гена <em>(parent gene
type).</em></p></td>
</tr>
<tr class="odd">
<td><code>--sjdbOverhang</code></td>
<td><code>100</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>длина донорской/акцепторной последовательности с
каждой стороны экзон-экзонного стыка. В идеале
должно быть на 1 короче длины рида.</p></td>
</tr>
<tr class="even">
<td><code>--sjdbScore</code></td>
<td><code>2</code></td>
<td><p><strong>целое число</strong></p>
<p>Дополнительный бонус за выравнивание <em>(extra
alignment score)</em>, которое пересекает базу экзонных
стыков.</p></td>
</tr>
<tr class="odd">
<td><code>--sjdbInsertSave</code></td>
<td><code>Basic</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает, какие файлы сохранять, когда информация
об экзонных стыках добавляется на стадии
выравнивания:</p>
<p><code>Basic</code> - только малые стыки/файлы с транскриптами;</p>
<p><code>All</code> - все файлы, включая дополнительные файлы
индексов. По сути это создаст измененную копию
геномного индекса в папке, из которой была запущена
программа.</p></td>
</tr>
</tbody>
</table>
<ul>
<li><em>Параметры прочтений</em></li>
</ul>
<table>
<colgroup>
<col width="31%" />
<col width="13%" />
<col width="55%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по
умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--readFilesType</code></td>
<td><code>Fastx</code></td>
<td><p><strong>строка</strong></p>
<p>Формат, в котором предоставлены риды:</p>
<p><code>Fastx</code> - либо FASTA, либо FASTQ;</p>
<p><code>SAM SE</code>- SAM или BAM выравнивания односторонних
прочтений<sup><strong>1</strong></sup>;</p>
<p><code>SAM PE</code>- SAM или BAM выравнивания двусторонних
прочтений<sup><strong>1</strong></sup>.</p>
<p><strong>1 -</strong> При работе с BAM файлами используйте параметр
<code>--readFilesCommand samtools view</code></p></td>
</tr>
<tr class="even">
<td><code>--readFilesSAMattrKeep</code></td>
<td><code>All</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает, какие флаги в SAM-файле, предоставленном в качестве
файла с прочтениями (<code>--readFilesType SAM PE/SE</code>), сохранить в
BAM-файле с выравниваниями. Это аналог опции
<code>--readFilesSAMtagsKeep RG PL</code>. Варианты:</p>
<p><code>All</code> - оставить все флаги;</p>
<p><code>None</code> - не оставлять флаги.</p></td>
</tr>
<tr class="odd">
<td><code>--readFilesIn</code></td>
<td><code>Read1 Read2</code></td>
<td><p><strong>пути к файлам</strong></p>
<p>Адреса файлов c прочтениями. Сначала первый рид (или список
через запятую), потом спаренные риды через пробел (если есть).</p>
<p>Примеры:</p>
<p><code>--readFilesIn file1.fq.gz</code> (один файл с односторонним
прочтением)</p>
<p><code>--readFilesIn fil e1.fq.fz,file2.fq.gz,file3.fq.gz</code>
(односторонние прочтения разделены на три файла)</p>
<p><code>--readFiles In file1_R1.fq.fz file1_R2.fq.gz</code> (спаренные
риды, по одному файлу каждого)</p>
<p><code>--readF iles In file1_R1.fq.fz,file2_R1.fq file1_R2.fq.gz,file2_R2.fq</code>
(спаренные риды, несколько файлов)</p>
<p>Если файлов с ридами много (указаны через запятые), то в файл
выравнивания можно добавить специальный флаг <code>ID:</code>. Для этого
нужно воспользоваться опцией <code>--outSAMattrRGline</code>, предоставив
ей список названий для групп ридов через
пробел-запятую-пробел:</p>
<p><code>--readFilesIn fil e1.fq.fz,file2.fq.gz,file3.fq.gz</code></p>
<p><code>--outSAMattrRGline ID:s ample1 , ID:sample2 , ID:sample3</code></p>
<p>В примере выравниваются три файла, риды из каждого будут
помечены. Обратите внимание, префикс <code>ID:</code> указан перед
названием группы, а записи для образцов разделены не запятой,
а запятой с пробелами с двух сторон.</p></td>
</tr>
<tr class="even">
<td><code>--readFilesManifest</code></td>
<td><strong><code>-</code></strong></td>
<td><p><strong>путь к файлу</strong></p>
<p>Адрес к файлу с таблицей, содержащей адреса файлов с
прочтениями <em>(manifest file)</em>. Это дает возможность
выравнивать несколько экспериментов в одном запуске.</p>
<p>Таблица состоит из трех столбцов, разделенных табуляцией:</p>
<p>file1_R1.fq (tab) file1_R2.fq (tab) строка_флагов1</p>
<p>file2_R1.fq (tab) file2_R2.fq (tab) строка_флагов2</p>
<p>Для случая с односторонними прочтениями вместо второго рида
указывается <code>-</code>:</p>
<p>file1.fq (tab) - (tab) строка_флагов1</p>
<p>file2.fq (tab) - (tab) строка_флагов2</p>
<p>Строка флагов может начинаться с префикса <code>ID:</code>, в таком
случае может здесь можно перечислить несколько флагов через
табуляцию.</p>
<p>Если в строке флагов нет префикса <code>ID:</code>, то название группы
может быть только одноодин, префикс <code>ID:</code> будет добавлен к
нему автоматически.</p>
<p>Все флаги будут записаны дословно в строку заголовков <code>@RG</code>
SAM-файла.</p></td>
</tr>
<tr class="odd">
<td><code>--readFilesCommand</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>Команда, которую STAR должен запустить в командной строке
перед загрузкой файлов с прочтениями.</p>
<p>STAR не умеет работать со зжатыми файлами. Чтобы открыть их,
ему необходимо написать команду, при помощи которой он сможет
деархивировать файлы. Эта команда должна сгенерировать из
входных файлов текст, который будет отправлен в <code>STDOUT</code>.</p>
<p>Для чтения файлов <code>.fastq.gz</code>, в этой опции нужно указать
<code>--readFilesCommand zcat</code> <sup><strong>1</strong></sup> или
<code>--readFilesCommand gunzip -c</code> <sup><strong>2</strong></sup>.</p>
<p>Для чтения файлов <code>.fastq.bz</code>, в этой опции нужно указать
<code>--readFilesCommand bzcat</code> <sup><strong>1</strong></sup> или
<code>--readFilesCommand bunzip2 -c</code> <sup><strong>2</strong></sup>.</p>
<p><strong>1 -</strong> команда <code>zcat</code> или <code>bzcat</code> считывает сжатый текстовый
файл и выводит в <code>STDOUT</code>, то есть на экран терминала.</p>
<p><strong>2 -</strong> команды <code>bunzip2</code> или <code>gunzip</code> деархивируют сжатые
файлы и выводит содержимое в <code>STDOUT</code> при наличии опции <code>-c</code>.</p></td>
</tr>
<tr class="even">
<td><code>--readFilesPrefix</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>Префикс, который нужно добавить к названиям файлов в команде
<code>--readFilesIn</code>, чтобы получился полный путь к файлам.</p></td>
</tr>
<tr class="odd">
<td><code>--readMapNumber</code></td>
<td><code>-1</code></td>
<td><p><strong>целое число</strong></p>
<p>Число ридов с начала файла, которые нужно выравнить на геном.
Позволяет делать проверочные запуски выравнивания. Значение
<code>-1</code> заставляет выравнить все риды.</p></td>
</tr>
<tr class="even">
<td><code>--readMatesLengthsIn</code></td>
<td><code>NotEqual</code></td>
<td><p><strong>строка</strong></p>
<p>Стоит ли программе ожидать, что длина имен,
последовательностей, строки качества в файлах со спаренными
ридами одинакова. Варианты: <code>Equal</code> или <code>NotEqual</code>. Последний
вариант самый безопасный.</p></td>
</tr>
<tr class="odd">
<td><code>--readNameSeparator</code></td>
<td><code>/</code></td>
<td><p><strong>строка</strong></p>
<p>Символ в названии ридов (в FASTQ-файлах это строка,
начинающаяся с <code>@</code>, в FASTA - строка, начинающаяся с <code>&gt;</code>), по
которому будут обрезаться названия ридов в итоговом файле с
выравниваниями. Если в названии ридов есть пробел, то после
него название ридов всегда будут обрываться.</p></td>
</tr>
<tr class="even">
<td><code>--readQualityScoreBase</code></td>
<td><code>33</code></td>
<td><p><strong>неотрицательное целое число</strong></p>
<p>Базовое значение для кодировки
<a href="https://en.wikiped%20ia.org/wiki/Phred_quality_score">Phred
-score</a>.
Символ с этим номером в таблице ASCII будет восприниматься как
Phred=0. Для запусков Illumina использовать 33. Для запусков
Solexa - 64.</p></td>
</tr>
</tbody>
</table>
<ul>
<li><em>Обрезание ридов</em></li>
</ul>
<table>
<colgroup>
<col width="25%" />
<col width="31%" />
<col width="43%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--clipAdapterType</code></td>
<td><code>Hamming</code></td>
<td><p><strong>строка</strong></p>
<p>Способ удаления адаптера:</p>
<p><code>Hamming</code> - обрезание адаптера на основе
дистанции Хамминга. Число несовпадающих
нуклеотдиов определяется параметром
<code>--clip5pAdapterMMp</code>;</p>
<p><code>CellRanger4</code> - 5’- и 3’- будут удалены
аналогично способу, описанному в программе
<code>CellRanger4</code> из пакета
<a href="https://github.com/Martinsos/opalNoneno">Opa
l</a>;</p>
<p><code>None</code> - обрезания не происходит. Все
парамтры, необходимые для обрезания,
игнорируются.</p></td>
</tr>
<tr class="even">
<td><code>--clip3pNbases</code></td>
<td><code>0</code></td>
<td><p><strong>целые числа</strong></p>
<p>Число оснований, которое будет удалено с 3’
конца каждой пары. Если задано одно число,
то программа будет удалять заданное
количетсво букв у обоих спаренных ридов.</p></td>
</tr>
<tr class="odd">
<td><code>--clip3pAdapterSeq</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>Удалит заданную последовательность адаптера
с 3’ конца ридов. Если записана одна
последовательность, то левый и правый риды
будут обризаться одинаково.</p>
<p>Можно задать значение <code>polyA</code>, это будет
эквивалентно поли-А-хвосту с длиной, равной
длине рида.</p></td>
</tr>
<tr class="even">
<td><code>--clip3pAdapterMMp</code></td>
<td><code>0.1</code></td>
<td><p><strong>вечественное число</strong></p>
<p>максимальная доля несовпадающих букв на
3’-конце рида в сравнении с
последовательностью адаптера. Если приведено
два числа, то для левого и правого рида этот
параметр будет отличаться.</p></td>
</tr>
<tr class="odd">
<td><code>-- clip3pAfterAdapterNbases</code></td>
<td><code>0</code></td>
<td><p><strong>целое число</strong></p>
<p>Число оснований, которое будет удалено с
3’-конца ридов после удаления адаптеров.
Можно указать два числа для разных спаренных
ридов.</p></td>
</tr>
<tr class="even">
<td><code>--clip5pNbases</code></td>
<td><code>0</code></td>
<td><p><strong>целое число</strong></p>
<p>Число оснований, которое будет удалено с 5’
конца каждой пары. Если задано одно число,
то программа будет удалять заданное
количетсво букв у обоих спаренных ридов.</p></td>
</tr>
</tbody>
</table>
<ul>
<li><em>Огриничения памяти</em></li>
</ul>
<table style="width:72%;">
<colgroup>
<col width="16%" />
<col width="12%" />
<col width="43%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Зн
ачение
по
умо
лчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--limit GenomeGen erateRAM</code></td>
<td><code>310000 00000</code></td>
<td><p><strong>целое положительное
число</strong></p>
<p>Максимальный объем
оперативной памяти (байт)
для генерации генома</p></td>
</tr>
<tr class="even">
<td><code>-- limitIObu fferSize</code></td>
<td><code>300000 00 500 00000</code></td>
<td><p><strong>целое положительное
число</strong></p>
<p>Максимальный объем буфера
(байт) для ввода/вывода на
поток</p></td>
</tr>
<tr class="odd">
<td><code>--limitO utSAMoneR eadBytes</code></td>
<td><code>1 00000</code></td>
<td><p><strong>целое положительное
число</strong></p>
<p>Максимальный размер одной
записи в SAM-файле (байт) на
рид. Рекомендуется значение:</p>
<p>&gt;
(2*(LengthMate1+LengthMate2
+100)*outFilterMultimapNmax</p></td>
</tr>
<tr class="even">
<td><code>-- limitOutS JoneRead</code></td>
<td><code>1000</code></td>
<td><p><strong>целое положительное
число</strong></p>
<p>Максимальное число экзонных
стыков на рид (учитывая все
множественные выравнивания)</p></td>
</tr>
<tr class="odd">
<td><code>--li mitOutSJc ollapsed</code></td>
<td><code>10 00000</code></td>
<td><p><strong>целое положительное
число</strong></p>
<p>Максимальное число экзонных
стыков после удаления
дупликатов</p></td>
</tr>
<tr class="even">
<td><code>--limitBA MsortRAM</code></td>
<td><code>0</code></td>
<td><p><strong>целое положительное
число</strong></p>
<p>Максимальное количество
оперативной памяти для
сортировки BAM. Если равно
0, то будет равно размеру
индекса. Значение 0 может
быть использовано только
вместе с параметром
<code>- -genomeLoad NoSharedMemory</code>.</p></td>
</tr>
<tr class="odd">
<td><code>--l imitSjdbI nsertNsj</code></td>
<td><code>10 00000</code></td>
<td><p><strong>целое положительное
число</strong></p>
<p>Максимальное число экзонных
стыков, которое можно
вставить в том случае, если
анализ экзон-экзонных стыков
происходит на стадии
выравнивания.</p></td>
</tr>
<tr class="even">
<td><code>--limitNr eadsSoft</code></td>
<td><code>-1</code></td>
<td><p><strong>целое число</strong></p>
<p>Мягкое ограничение на число
ридов. <code>-1</code> означает
бесконечность.</p></td>
</tr>
</tbody>
</table>
<ul>
<li><em>Общие настройки вывода</em></li>
</ul>
<table style="width:99%;">
<colgroup>
<col width="22%" />
<col width="22%" />
<col width="54%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по
умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--outFi leNamePrefix</code></td>
<td><code>./</code></td>
<td><p><strong>строка</strong></p>
<p>Префикс, который будет добавлен к
названию файлов оутпута. Это может
быть адрес папки, куда вы хотите
сохранить все файлы.</p></td>
</tr>
<tr class="even">
<td><code>--outTmpDir</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>Fastxпуть к директории для временных
файлов. Все содержимое будет удалено
по покончании программы.</p></td>
</tr>
<tr class="odd">
<td><code>--outTmpKeep</code></td>
<td><code>None</code></td>
<td><p><strong>строка</strong></p>
<p>Сохранять временные файлы после
завершения программы (выбрать <code>All</code>)
или нет (выбрать <code>None</code>).</p></td>
</tr>
<tr class="even">
<td><code>--outStd</code></td>
<td><code>Log</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает, какой из файлов будет
направлен в STDOUT (на экран
терминала). Варианты - логи <code>Log</code>,
SAM-файл <code>SAM</code>, несортированный
BAM-файл <code>BAM_Unsorted</code>,
сортированный по координатам BAM
файл <code>BAM_SortedByCoordinate</code>,
выравненные на транкриптом фрагменты
<code>BAM Quant</code>.</p></td>
</tr>
<tr class="odd">
<td><code>--outR eadsUnmapped</code></td>
<td><code>None</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает, сохранить ли
невыравненные или
частичновыравненные риды в отдельный
файл. Есть вариант <code>None</code> и <code>Fastx</code>.
В последнем случае будет сохранен
отдельный FASTA/FASTQ-файл с
названием <code>Unmapped.out.mate1/2</code></p></td>
</tr>
<tr class="even">
<td><code>--outQSc onversionAdd</code></td>
<td><code>0</code></td>
<td><p><strong>целое число</strong></p>
<p>Заставляет добавить число к
Phred-score. Позволяет
конвертировать Phred между
кодировкой +33 и +64. Например,
можно добавить к значениям качества
Illumina 31, чтобы получить
кодировку Phred+64.</p></td>
</tr>
<tr class="odd">
<td><code>--outMult imapperOrder</code></td>
<td><code>Old_2.4</code></td>
<td><p><strong>строка</strong></p>
<p>Порядок перечисления ридов с
множественными выравниваниями в
результатах:</p>
<p><code>Old_2.4</code> - квази-рандомный,
используемых в версии STAR до 2.5.0.</p>
<p><code>Fastx</code> - рандомный порядок
перечисления. Все выравнивания
одного рида перечисляются друг за
другом.</p></td>
</tr>
</tbody>
</table>
<ul>
<li>Настройки вывода SAM/BAM</li>
</ul>
<table>
<colgroup>
<col width="24%" />
<col width="16%" />
<col width="60%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение
по
умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--outSAMtype</code></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>--outSAMmode</code></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>--out SAMstrandField</code></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>--ou tSAMattributes</code></td>
<td><code>Standard</code></td>
<td><p><strong>строка</strong></p>
<p>Задает список атрибутов SAM-файла, которые
нужно вывести. Эти параметры будут
находиться в 12-м опциональном поле
таблицы вырвавниваний в виде записей
формата Тэг:Tип_переменной:Значение.
Например, <code>FI:i:1 TC:i:3</code> (здесь i
означает integer, целое число).</p>
<p>Пресеты:</p>
<p><code>None</code> - никаких атрибутов</p>
<p><code>Standard</code> - NH HI AS nM</p>
<p><code>All</code> - NH HI AS nM NM MD jM jI MC ch</p>
<p>Варианты атрибутов, описывающих
<strong>вырванивание</strong>:</p>
<p><code>NH</code> - число локусов, на которые рид
картируется (1 для ридов с одним
выравниванием);</p>
<p><code>HI</code> - индекс множественного выравнивания.
Начинается с числа, заданного параметром
<code>--outSAMattrIHstart</code>;</p>
<p><code>AS</code> - скор локального выравнивания. +1/-1
за совпадение/несовпадение, плюс пенальти
за инделы и пропуски. Для PE режима скор
равен сумме для двух спаренных ридов;</p>
<p><code>nM</code> - число замен. Для PE режима
суммируется по обоим ридам;</p>
<p><code>NM</code> - дистанция от референса. Считается
как число событий редактирования, нужное,
чтобы из одной последовтельности получить
вторую;</p>
<p><code>MD</code> - строка, в которой закодированы
основания референса, в которых произошли
замены или делеции;</p>
<p><code>jM</code> - интронный мотив для всех экзонных
стыков. 0:неканоничный; 1:GT/AG, 2: CT/AC,
3: GC/AG, 4: CT/GC, 5: AT/AC, 6: GT/AT.
Если использовалась база аннотированных
сплайс-сайтов, то к каждому мотиву
добавляется 20;</p>
<p><code>jI</code> - старт и конец интронов (системе
отсчета +1);</p>
<p><code>XS</code> - цепь референса, на которую
выравнился рид согласно
<code>--outSAMstrandField</code>;</p>
<p><code>MC</code> -
<a href="htt%20ps://drive5.com/usearch/manual/cigar.html">CIGAR</a>
строка для спаренного рида;</p>
<p><code>ch</code> - помечает все сегменты всех химерных
выравниваний для
<code>--chimOutType WithinBAM</code>;</p>
<p><code>cN</code> - число оснований, которые были
удалены с 5’ и 3’-концов.</p>
<p>Варианты атрибутов, доступные в режиме
работы с <strong>мутантными вариантами</strong>:</p>
<p><code>vA</code> - аллельный вариант;</p>
<p><code>vG</code> - координата варианта, перекрытого
ридом;</p>
<p><code>vW</code> - 1 - выравнивание прошло фильтрацию
WASP, 2-7 - выранвивание не прошло
фильтрацию WASP. Указывается только при
включенной опции
<code>--waspOutputMode SAMtag</code>.</p>
<p>Варианты атрибутов, доступные в режиме
работы <strong>STARsolo</strong> (демультиплексирование
scRNA-seq выравниваний):</p>
<p><code>CR</code> <code>CY</code> <code>UR</code> <code>UY</code> - последовательности
(R) и качество (Y) клеточных (С) баркодов
и UMI (U);</p>
<p><code>GX</code> <code>GN</code> - gene ID и gene name для ридов,
попадающих в уникальных ген;</p>
<p><code>gx</code> <code>gn</code> - gene ID и gene name для ридов,
попадающих в уникальный ген или в
несколько генов;</p>
<p><code>CB</code> <code>UB</code> - клеточные баркоды и UMI после
коррекции ошибок. Требуется установка
параметра
<code>--outSAMtype BAM SortedByCoordinate</code>;</p>
<p><code>sM</code> -</p>
<p><code>sS</code> - вся последовательность баркода;</p>
<p><code>sQ</code> - качество всего баркода.</p></td>
</tr>
<tr class="odd">
<td><code>--out SAMattrIHstart</code></td>
<td><code>1</code></td>
<td><p><strong>целое неотрицательное число</strong></p>
<p>Начальное значение для атрибута IH.
Значение 0 может быть обязательным для
некоторых программ, таких как
<strong>Cufflinks</strong> или <strong>StringTie</strong></p></td>
</tr>
<tr class="even">
<td><code>-- outSAMunmapped</code></td>
<td><code>None</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает, как выводить некартированные
риды. Параметр состоит из двух частей.</p>
<p>Первая часть:</p>
<p><code>None</code> - не выводить;</p>
<p><code>Within</code> - вывести в основной SAM-файл.</p>
<p>Вторая часть:</p>
<p><code>KeepPairs</code> - записать непрокартированные
спаренные риды рядом с прокартированной
парой (если не было сортировки). Этот
пункт имеет значение только для ридов с
множественными выравниваниям.</p></td>
</tr>
<tr class="odd">
<td><code>--outSAMorder</code></td>
<td><code>Paired</code></td>
<td><p><strong>строка</strong></p>
<p>Тип сортировка для ридов в выравнивании:</p>
<p><code>Paired</code> - каждый спаренный рид помещается
рядом с парой</p>
<p><code>PairedKeepInputOrder</code> - спаренные риды
лежат друг за дружкой, но порядок ридов
совпадает с исходным в FASTQ или FASTA.</p></td>
</tr>
<tr class="even">
<td><code>--out SAMprimaryFlag</code></td>
<td><code>OneB estScore</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает, какое выравнивание считать
первичным. Все остальные выравнивания
получат флаг 0x100 (В флаге восьмой бит
справа будет приравнен 0).</p>
<p><code>OneBestScore</code> - одно выравнивание с
высшим скором будет считаться первичным;</p>
<p><code>AllBestScore</code> - все вырванивания с высшим
скором будут считаться первичными.</p>
<p>FLAG - это двоичное 16-битовое число,
каждая цифра в котором указывает на
определенное свойство рида. Например, если
первый бит (0x1 в 16-ричной нотации) равен
единице, то рид считается спаренным (0 -
наоборот). Если второй бит (0x2 в
16-ричной нотации) равен 1, то рид
выравнен правильно вместе со своей парой
(0 - наоборот). Если записать два бита
одним двоичным числом, то число 11<sub>2</sub>
означает, что рид имеет пару, и оба рида в
паре правильно выравнены. А если мы видим
число 01<sub>2</sub>, то рид имеет пару, но оба
выранены неправильно (дискордантно,
например). Любое число в двоичной системе
можно выразить в десятеричной. Например,
11<sub>2</sub> эквивалентно 4<sub>10</sub>. Расшифровку
флагов можно посмотреть
<a href="https://broadinsti%20tute.github.io/picard/explain-flags.html">онлайн-калькуляторе</a>,
его <a href="ht%20tps://www.samformat.info/sam-format-flag">более красивой
версии</a>,
или <a href="htt%20ps://www.youtube.com/watch?v=qm4NGV79t4o">видео
туториале</a>.</p></td>
</tr>
<tr class="odd">
<td><code>--outSAMreadID</code></td>
<td><code>Standard</code></td>
<td><p><strong>строка</strong></p>
<p>Тип записи для идентификатора рида <em>(read
ID):</em></p>
<p><code>Standard</code> - первое слово (до пробела) в
заголовке FASTQ или FASTA. Суффиксы <code>/1</code> и
<code>/2</code> будут удалены.</p>
<p><code>Number</code> - номер рида <em>(index)</em> в FASTQ
или FASTA.</p>
<p>Read ID указан в первой колонке SAM-файла
(поле QNAME).</p></td>
</tr>
<tr class="even">
<td><code>--ou tSAMmapqUnique</code></td>
<td><code>255</code></td>
<td><p><strong>целое число от 0 до 255</strong></p>
<p>Устанавливает качество выравнивания для
уникально-картируемых ридов. Это число
будет записано во второй колонке (поле
MAPQ) внутри SAM-файла.</p></td>
</tr>
<tr class="odd">
<td><code>--outSAMflagOR</code></td>
<td><code>0</code></td>
<td><p><strong>целое число от 0 до 65535</strong></p>
<p>Изменяет флаги в SAM-файле при помощи
операции OR. После того, как STAR
сформирует выравнивания, раздел FLAG
SAM-файла будет сложет с заданным числом.
Может пригодится для <a href="https://broadinsti%20tute.github.io/picard/explain-flags.html">фильтрации
выравниваний на основе
флагов</a>.</p>
<p>Подробнее про флаги можно прочитать в
разделе про <code>--outSAMprimaryFlag</code>.</p>
<p>Поскольку в двоичной форме с любой цифрой
можно проводить логические операции, то
флаги можно модифицировать. STAR позволяет
конвертировать флаги в итоговом
выравнивании с помощью операций AND и OR.
Например, можно модифицировать флаг 00 с
помощью операции 01 AND 10. Получится 00.
Или можно выполнить операцию 01 OR 10 -
получится 11.</p></td>
</tr>
<tr class="even">
<td><code>- -outSAMflagAND</code></td>
<td><code>65535</code></td>
<td><p><strong>целое число от 0 до 65535</strong></p>
<p>Изменяет флаги в SAM-файле при помощи
операции AND. После того, как STAR
сформирует выравнивания, раздел FLAG
SAM-файла будет сложет с заданным числом.
Может пригодится для <a href="https://broadinsti%20tute.github.io/picard/explain-flags.html">фильтрации
выравниваний на основе
флагов</a>.</p>
<p>Подробнее про флаги можно прочитать в
разделе про <code>--outSAMprimaryFlag</code>.</p>
<p>Подробнее про операции над флагами можно
прочитать в разделе про <code>--outSAMflagOR</code> .</p></td>
</tr>
<tr class="odd">
<td><code>--ou tSAMattrRGline</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>Задает строку атрибутов в выравниваниях
SAM-файла. Должна начинаться с тега <code>ID:</code></p>
<p>Атрибуты для разных вводных файлов могут
отличаться, для чего нужно будет написать
несколько строк атрибутов через
пробел-запятую-пробел:</p>
<p><code>--outSAMattrRGline ID:xxx , ID:zzz "DS:z z" , ID:yyy DS:yyyy</code></p>
<p>Обратите внимание, что теги, чье
содержимое содержит пробелы, нужно писать
в кавычках.</p></td>
</tr>
<tr class="even">
<td><code>-- outSAMheaderHD</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>Задает первую строку заголовка (несет @HD
флаг) SAM</p></td>
</tr>
<tr class="odd">
<td><code>-- outSAMheaderPG</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>Дополнительная строка в SAM-заголовке.
Будет нести тег @PG (программное
обеспечение).</p></td>
</tr>
<tr class="even">
<td><code>--outSAMhea derCommentFile</code></td>
<td><code>-</code></td>
<td><p><strong>путь к файлу</strong></p>
<p>название файла, куда буду записаны
коммендарии из SAM заголовка (несет тег
@CO)</p></td>
</tr>
<tr class="odd">
<td><code>--outSAMfilter</code></td>
<td><code>None</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает, нужно ли записывать
выравнивания на референсные
последовательности, добавленные с помощью
<code>--genomeFastaFiles</code> на этапе
картирования, в основной SAM/BAM файл.</p>
<p><code>KeepOnlyAddedReferences</code> - сохранить
только те выравнивания, что попадают на
добавочный референс.</p>
<p><code>KeepAllAddedReferences</code> - сохранить все
выравнивания в одном файле.</p>
<p>По умолчанию стоит <code>None</code>, то есть
выравнивания на дополнительный референс
сохраняются в отдельном файле.</p></td>
</tr>
<tr class="even">
<td><code>-- outSAMmultNmax</code></td>
<td><code>-1</code></td>
<td><p><strong>целое</strong></p>
<p>Максимальное число выравниваний, которое
сообщается для ридов с множественными
выравниваниями. По умолчанию стоит -1, то
есть сообщаются все (влоть до
<code>--outFilterMultimapNmax</code>).</p></td>
</tr>
<tr class="odd">
<td><code>--outSAMtlen</code></td>
<td><code>1</code></td>
<td><p><strong>целое</strong></p>
<p>метод вычисления поля TLEN <em>(template
length, длина фрагмента)</em> в SAM/BAM файле.</p>
<p><code>1</code> - от самого крайнего основания первого
рида до самого крайнего основания второго
рида.</p>
<p><code>2</code> - по крайним основаниям
безотносительно от рида. Это
принципиально, если один из ридов лег
внутри второго (такое часто бывает после
обрезания 5’-конца ридов).</p></td>
</tr>
<tr class="even">
<td><code>--out BAMcompression</code></td>
<td><code>-1</code></td>
<td><p><strong>целое от -1 до 10</strong></p>
<p>Уровень сжатия BAM-файла. Чем больше, тем
сильнее сжатие. -1 означает обычное сжатие
(~6).</p></td>
</tr>
<tr class="odd">
<td><code>--outBAM sortingThreadN</code></td>
<td><code>0</code></td>
<td><p><strong>целое неотричательное число</strong></p>
<p>Число потоков для сортировки BAM-файла</p></td>
</tr>
<tr class="even">
<td><code>--outB AMsortingBinsN</code></td>
<td><code>50</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Число геномных фрагментов при сортировке
по координатам</p></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
