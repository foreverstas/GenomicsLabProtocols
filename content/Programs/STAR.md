---
title: "STAR"
author: "Stanislav Romanov"
date: '2023-03-22'
tags: ["RNA-seq", "STAR","short read alignment"]
editor_options: 
  markdown: 
    wrap: 400
    toc: true
---

# Назначение STAR

Процесс выравнивания отсеквенированных последовательностей состоит из выбора подходящего эталонного генома для картирования полученных прочтений и выравнивания прочтений с использованием одного из нескольких инструментов. В отличие от других ChIP-seq или секвенирования генома, прочтения RNA-seq содержат сплайсированные последовательности. Это означает, что прямое сопоставление прочтений с
референсом путем выравнивания ридов по всей длине сделает невозможным картирование большинства фрагментов. Это свойство транскриптов учитывается несколькими элайнерами, среди которых наиболее популярны [STAR](https://academic.oup.com/bioinformatics/article/29/1/15/272537), [HISAT2](https://daehwankimlab.github.io/hisat2/) или [TopHat](https://ccb.jhu.edu/software/tophat/manual.shtml). Выбор
элайнера часто является личным предпочтением, а также зависит от доступных вам вычислительных ресурсов.

{{% notice "info" %}}
STAR стал популярным по нескольким причинам. Во-первых, это один из самых быстрых элайнеров. Во-вторых, точность выравнивания с помощью STAR в ряде тестов превышает конкурентов (не всегда). Пожалуй, по производительности он может уступать только Hisat2 (и то не всегда). Однако в отличие от последнего он предоставляет подробный отчет о положении сайтов-сплайсинга, может сразу подсчитывать число прочтений в транскриптах, строит профиль покрытия генома прочтениями (signal file), делает анализ нуклеотидных вариантов в прочтениях, оптимизирован для анализа single cell RNA-seq и пр. STAR активно поддерживается разработчиками, благодаря чему в нем постоянно появляются новые функции. Его ключевым недостатком является высокая требовательность к оперативной памяти. В тестах его требования к памяти превышают таковые у Hisat2 в 5-10 раз (20-40 Gb оперативной памяти при анализе генома человека).
{{% /notice %}}

# Описание алгоритма

Большинство популярных инструментов выравнивания ридов RNA-seq были разработаны как усовершенствованные версии программ выравнивания непрерывных коротких последовательностей ДНК (**bowtie**, **bwa** и пр.) и основаны либо на выравнивания коротких прочтений по базе экзон-экзонных стыков *(splice junctions)*, либо на выравнивании сегментов рида на непрерывную последовательность эталонного генома,
либо на комбинации двух подходов. В отличие от них STAR был разработан для выравнивания сплайсированных последовательностей непосредственно на эталонный геномом. Алгоритм STAR состоит из двух основных этапов: этап поиска зерновых последовательностей *(seed)* и этап кластеризации/сшивки/скоринга *(clustering/stitching/scoring)*.

{{% expand "Развернутое описание" %}}

Центральной идеей этапа поиска зерновых последовательностей STAR является последовательная процедура поиска максимального картируемого префикса *(Maximal Mappable Prefix, MMP)*. Говоря математическим языком, если обозначить последовательность рида как R, номер нуклеотида внутри рида как i, а эталонную последовательность генома за G, то функция MMP(R,i,G) вернет самую длинную подстроку (Ri, Ri+1,
… , Ri+MML- 1), которая точно совпадает с одной или несколькими подстроками G, где MML – это максимальная картируемая длина. На первом этапе алгоритм находит MMP начиная с первого нуклеотида в риде. Риды, которые содержат экзон-экзонный стык, не могут быть выравнены на референсный геном всей длиной. Однако благодаря алгоритму MMP первое зерно будет соответствовать донорскому сайту сплайсинга.
Далее поиск MMP повторяется, но уже для оставшейся непрокартированной части рида, которая в данном случае будет выравнена на акцепторный сайт сплайсинга. Последовательное применение MMP-поиска только к некартированным участкам рида делает алгоритм STAR чрезвычайно быстрым. Поиск MMP в STAR реализуется через алгоритм несжатых *(Uncompressed)* суффиксных деревьев *(Suffix Arrays, SA)*.
Примечательно, что поиск MMP является неотъемлемым результатом стандартного бинарного поиска строк в несжатых SA и не требует дополнительных вычислительных усилий по сравнению с полноразмерным поиском точного соответствия. Бинарная природа поиска в SA приводит к тому, что время поиска оказывается связано с длиной эталонного генома логарифмически, что обеспечивает быстрый поиск даже в больших
геномах. Преимуществом является то, что для каждого MMP поиск SA может найти все отдельные точные геномные совпадения с небольшими вычислительными затратами, что облегчает точное выравнивание ридов, которые сопоставляются с несколькими геномными локусами *(multipammed reads)*.

![](/Programs/STAR.files/fig1.png?width=40pc)

Помимо обнаружения сплайс-cайтов, поиск MMP позволяет находить множественные несоответствия и инделы. Если поиск MMP не достигает конца рида из-за наличия одного или нескольких несоответствий, MMP служат якорями внутри рида, которые можно расширять на референс, что делает возможным выравнивание ридов с ошибками. В некоторых случаях процедура расширения выравниваний *(extension)* не дает хорошего
результата, что позволяет идентифицировать поли-А хвосты, последовательности библиотечных адаптеров или хвосты ридов с низким качеством секвенирования. Поиск MMP осуществляется как в прямом, так и в обратном направлении последовательности рида и может быть начат с заданных пользователем точек начала поиска по всей длине рида, что облегчает поиск якорей для ошибочных последовательностей на концах
ридов и повышает чувствительность картирования в условиях высокой частоты ошибок секвенирования.

Помимо эффективного алгоритма поиска MMP, несжатые SA также демонстрируют значительное преимущество в скорости по сравнению со сжатыми SA, реализованными во многих популярных выравнивателях коротких ридов. Однако высокая скорость компенсируется увеличенной требовательностью к памяти.

На втором этапе алгоритма STAR строит выравнивание всей последовательности прочтений путем сшивания *(stitching)* всех затравочных подстрок, которые были выровнены по геному на первом этапе. Сначала зерновые последовательности объединяются в кластеры по расстоянию от выбранного набора “якорных” затравок *(anchors)*. Оптимальной процедурой для выбора якорей является ограничение числа геномных
локусов, с которыми выравниваются зерновые последовательности. Все зерновые подстроки, которые картируютс в заданных пользователем геномных окнах *(windows)* вокруг якорей, сшиваются вместе с использованием локальной линейной модели транскрипции. Размер геномных окон определяет максимальный размер интрона для сплайсированных выравниваний. Для сшивания каждой пары затравочных выравниваний
используется щадящий алгоритм динамического программирования, допускающий любое количество несовпадений, но только одну вставку или делецию *(gap)*.

Важно отметить, что зерновые выравнивания из парных прочтений RNA-seq кластеризуются и сшиваются одновременно, при этом спаренные риды представлены как разные последовательности, что допускает возможный геномный интервал или перекрытие между внутренними концами парных ридов. Это принципиальный способ использования информации о парных концах лучше отражает природу парных прочтений, а именно тот
факт, что пары представляют собой части (концы) одного и того же фрагмента ДНК. Такой подход повышает чувствительность алгоритма, так как для точного выравнивания всего прочтения достаточно одного правильного якоря от одного из ридов.

Если выравнивание в пределах одного геномного окна не покрывает всю последовательность рида (парных ридов), STAR попытается найти два или более окон, которые покрывают весь рид (оба рида), что приводит к химерному выравниванию, при котором разные части рида (ридов) отображаются на дистальные геномные локусы, или разные хромосомы, или разные нити. STAR может найти химерные выравнивания, в которых
пары ридов являются химерными друг для друга, с химерным соединением, расположенным в неотсеквенированной части молекулы РНК. STAR также может найти химерные выравнивания, в которых один или оба спаренных рида имеют внутреннее химерное выравнивание, что позволяет точно определить местоположение химерного соединения в геноме.

Скоринг осуществляется с помощью локальной схемы оценки выравнивания с заданными пользователем баллами (штрафами) за совпадения, несовпадения, вставки, удаления и разрывы сплайс-соединений, что позволяет количественно оценить качество и ранг выравнивания. Комбинация сшивок с наивысшим баллом выбирается в качестве наилучшего выравнивания ридов. Для ридов с множественными выравниваниями сообщается
обо всех выравниваниях с оценками в пределах определенного пользователем диапазона ниже наивысшей оценки.

Хотя последовательный поиск MMP находит только затравочные подстроки, точно соответствующие геному, последующая процедура сшивки способна выравнивать чтения с большим количеством несовпадений, инделов и сплайс-соединений с масштабированием на длину рида.

{{% /expand %}}

# Установка

{{% notice "warning" %}}
Установка возможна только на Linux или OSX. Можно также попробовать запустить на Windows через Docker-клиент. Однако есть большая веротность, что ноутбук не справится с запуском программы из-за высоких требований к оперативной памяти.
{{% /notice %}}

### Вариант 1. Клонирование репозитория из GutHub

В директории, где будет сохранена папка с программой, запустить команды:

    git clone https://github.com/alexdobin/STAR.git
    # Перейти в папку с исходными файлами программы
    cd STAR/source
    # Скомпилировать бинарные исходники
    make STAR
    cd ../bin
    # Добавить путь к бинарным исходникам STAR в переменную PATH
    export PATH=$PATH:$PWD

### Вариант 2. Распаковка из архива

Копировать ссылку на скачивание .tar.gz архива с нужной версией программы на сайте [GitHub](https://github.com/alexdobin/STAR/releases) (нажать правой кнопкой на гиперссылку “Source code (tar.gz)” в окошке с нужной версией программы и копировать).

Перейти в директорию, где будет храниться папка с программой STAR.

Вставить гиперссылку в команду wget, как показано ниже:

    wget https://github.com/alexdobin/STAR/archive/2.7.10b.tar.gz
    # скачается архив 2.7.10b.tar.gz
    # распаковать его можно с помощью программы tar:
    tar -xzf 2.7.10b.tar.gz
    # появится папка STAR-2.7.10b. Можно сразу переименовать ее
    mv STAR-2.7.10b STAR
    # дальше делаем то же самое, вто и в Варианте 1:
    cd STAR/source
    # Скомпилировать бинарные исходники
    make STAR
    cd ../bin
    # Добавить путь к бинарным исходникам STAR в переменную PATH
    export PATH=$PATH:$PWD

### Вариант 3. Самый простой. Установка при помощи Anaconda.

В командной строке вводим:

    conda install -c bioconda star

# Основные этапы выравнивания прочтений при помощи STAR

Как и в случае с другими элайнерами, выравнивание прочтений с помощью STAR — это двухэтапный процесс:

1.  Создание индекса на основе референсного генома.

{{% notice "info" %}}
Индекс - это сжатая версия текстовой последовательности генома. Фаловая структура индекса оптимизирована для быстрого поиска подпоследовательностей ДНК в геноме при помощи алгоритмов динамического программирования. Индекс создается один раз в папке назначения, и дальше используется неограниченное число раз для выравнивания ридов. Готовые индексы можно скачивать из интернета.
{{% /notice %}}

2.  Картирование прочтений на геном.

{{% notice "info" %}}
На этом этапе пользователь предоставляет папку с геномным индексом, а также файлы с прочтениями (последовательности) RNA-seq в формате FASTA или FASTQ. STAR сопоставляет прочтения с геномом и записывает несколько выходных файлов, включая выравнивание (SAM/BAM), сводную статистику, координаты экзон-экзонных стыков, невыравненные прочтения, профиль покрытия (wiggle) и т.д.
{{% /notice %}}

# Дополнительные возможности STAR

В отличие от других популярных элайнеров STAR предназначен также для анализа single cell RNA-seq. Такая возможность реализована через алгоритм **STARsolo**, доступный в режиме `soloCellFiltering`, который помимо выравнивания прочтений на геном, собирает информацию о баркодах разного типа и подсчитывает экспрессию генов в единичных клетках.

Алгоритм **STARconsensus**, доступный начиная с версии STAR 2.7.7a, позоляет картировать риды на консенсусный геном, что может пригодиться для идентификации аллель-специфичных транскриптов. Для этого достаточно во время выравнивания вместе с референсным индексом выдать программе [VCF-файл](https://en.wikipedia.org/wiki/Variant_Call_Format) с геномными вариантами.

Помимо этого, в STAR заложены широкие возможности по поиску и аннотации сайтов сплайсинга. Программа также подходит для анализа химерных последовательностей ДНК, которые могут возникать из-за неканонических событий сплайсинга (включая транс-сплайсинг), геномных делеций/инверсий/инсерций или из-за ошибок обратной транскрипции/амплификации.

Один из режимов работы программы - создание профиля покрытия *(signal file)* генома прочтениями (`inputAlignmentsFromBAM`) в формате wiggle или BedGraph. Это может быть удобно для визуализации RNA-seq профиля в геномном браузере.

В режиме работы `liftOver` STAR конвертирует GTF-файл с аннотацией генома между геномными сборками (например, между dm3 и dm6). Для конвертации необходимо дать программе [.chain](htt%20ps://genviz.org/m%20odul%20e-%2001-%20intro/0%20001/06/02/liftoverTools/) файл, в котором сопоставляю координаты разных сборок.

# Работа со STAR в командной строке

Запуск программы STAR происходит при помощи интерфейса командной строки. Программа запускается одной командой `STAR`, а режим работы (индексация генома, выравнивание и пр.) определяется обязательным параметром `--runMode`. Есть также версия программы `STARlong`, предназначенная, по-видимому, для выравнивания длинных прочтений. У нее практически те же самые параметры, что и у `STAR` (см. **Полный
список параметров**).

# Индексация генома

Для создания индекса программе нужен:

1.  fasta-файл (или несколько файлов, указанных списком через пробел) с референсным геномом.
2.  \[опционально\] gtf-файл с координатами генов/транскриптов. STAR извлечет из этого файла координаты экзон-экзонных стыков (сплайс-сайтов) и использует их для значительного повышения точности картирования. Этот файл необязателен, и STAR можно запускать без аннотаций. В то же время, использование аннотаций настоятельно рекомендуется создателями программы всегда, когда они доступны. Начиная с
    версии 2.4.1a, аннотации также могут быть включены “на лету” на этапе картирования.

{{% notice "info" %}}
Индексированный геном включает двоичную последовательность генома, деревья суффиксов, текстовые названия/длины хромосом, координаты сплайс-сайтов и информацию о транскриптах/генах. Большинство этих файлов используют внутренний формат STAR и не предназначены для использования конечным пользователем.  Настоятельно не рекомендуется изменять любой из этих файлов, за одним исключением: вы можете переименовать имена хромосом в файле chrName.txt, сохранив порядок хромосом в этом файле. Имена хромосом из этого файла будут использоваться во всех выходных файлах (например, SAM/BAM).
{{% /notice %}}

### Параметры для индексации генома

Основные параметры для создания индексированного генома с использованием STAR следующие:

-   `--runThreadN число_потоков` устанавливает многопоточный режим
-   `--runMode genomeGenerate` указывает программе, что она должна создать индексированный геном
-   `--genomeDir /путь/к/папке/для/хранения/индексов`
-   `--genomeFastaFiles /путь/к/FASTA1 /путь/к/FASTA2 ...`
-   `--sjdbGTFfile /путь/к/GTF`
-   `--sjdbOverhang длина_рида-1` используется программой для построения базы аннотированных экзонных стыков. Если величина равна 100, то STAR будет индексировать последовательности длиной 100 пар с каждой стороны от сайта сплайсинга. В идеале эта величина должна составлять длину рида минус 1. Например, для запуска в режиме 2x150 bp (спаренные риды длиной 150 пар), идеальным значением будет
    150-1=149. В случае, если риды имеют разную длину, то лучше выбрать длину самого протяженного рида и отнять единицу. Если этот параметр не указать, то программа воспользуется значением 100. Это значение отлично подходит в большинстве случаев.

{{% notice "tip" %}}
По логике вещей, параметр --sjdbOverhang вообще может быть сколько угодно больше длины рида. Так что если вы индексировали геном с параметром 149, а реальная длина ридов 75, то на результат это никак не повлияет. Единственное, чем он больше, тем больше памяти занимает индекс. Вообще же, если вы не предоставляете gtf-файл с аннотацией генома, то на этот параметр можно не обращать внимания, ибо он ни на что не повлияет.
{{% /notice %}}

В итоге, типичный пример команды для индексации генома выглядит так (символ `\` означает продолжение команды на новой строке):

    STAR --runThreadN 12 \ 
        --runMode genomeGenerate \ 
        --genomeDir ath_star_index \ 
        --genomeFastaFiles Athaliana_TAIR10.fasta \
        --sjdbGTFfile Athaliana_gene.gtf \
        --sjdbOverhang 149

{{% expand "Расширенные параметры" %}}

### Аннотация индексированного генома с помощью файла в GFF-формате

STAR может принимать аннотацию в формате [GFF3](https://learn.gencore.bio.nyu.edu/ngs-file-formats/gff3-format/#:~:text=General%20Feature%20Format%20(GFF)%20is,be%20handled%20by%20this%20format.). В таком случае такой файл нужно привести после параметра `--sjdbGTFfile`, и заодно указать параметр `--sjdbGTFtagExonParentTranscript Parent`. По умолчанию STAR ищет в каждой строке файла аннотации
фрагмент текста, начинающийся с “transcript_id=”. В формате GFF такой записи нет, вместо нее используется “Parent=”. Поскольку задачей STAR является поиск аннотированных экзон-экзонных стыков, во время процессинга GTF/GFF файлов он будет искать только строки, в которых 3й столбец содержит слово “exon”. Это поведение задается параметром по умолчанию `--sjdbGTFfeatureExon exon`.

Выглядеть это будет так:

    STAR --runThreadN 12 \ 
        --runMode genomeGenerate \ 
        --genomeDir ath_star_index \ 
        --genomeFastaFiles Athaliana_TAIR10.fasta \
        --sjdbGTFfile Athaliana_gene.gff3 \
        --sjdbGTFtagExonParentTranscript Parent \
        --sjdbOverhang 149

### Лист аннотированных экзон-экзонных стыков

STAR может принять для аннотации список экзон-экзонных стыков при помощи команды  
`--sjdbFileChrStartEnd /путь/к/сплайс_сайтам.tab`. Для этого необходимо подготовить отформатированную табулированную таблицу (без заголовков):

    Chr   Start   End   Strand

Start и End - это координаты первого и последнего нуклеотида в интроне (в системе координат **1-base**, где первый нуклеотид на хромосоме имеет координату 1). Strand - это “+”, “-” или “.”. Этот файл может иметь дупликаты, STAR сам их удалит.

Этот файл можно использовать как дополнение к GTF-файлу с аннотацией, а можно и без него. STAR сам разберется.

### Работа с короткими геномами

Если размер генома *L* меньше 1 Gb, то параметр `--genomeSAindexNbases` нужно понизить до величины log<sub>2</sub>(*L*)/2 - 1. Для дрозофилы это 13.

### Референсы с большим числом хромосом/скэффолдов/контигов

При работе с FASTA-файлами, в которых большое число последовательностей, можно понизить требования к оперативной памяти при помощи параметра `--genomeChrBinNbits`. Если обозначить длину генома за *L*, число последовательностей в референсном геноме за *N*, а длину рида за *l*, то наилучшим значением для этого параметра будет min(18,log<sub>2</sub>\[max(*L*/*N*,*l*)\]).

{{% /expand %}}

# Картирование прочтений

Для создания индекса программе нужен:

1.  Путь к папке с индексированным геномом.
2.  Пути к файлам с прочтениями в формате FASTA и FASTQ. Файлы могут быть сжатыми, однако STAR по умолчанию не умеет деархивировать файлы, поэтому в таком случае нужно написать команду, при помощи которой STAR сможет прочитать архивированные файлы.
3.  STAR также может извлекать риды из SAM/BAM-файлов, это может быть полезно для перевыравнивания.
4.  \[опционально\] Файл с аннотацией

{{% notice "tip" %}}
Список файлов с прочтениями может быть задан при помощи табулированного manifest-файла.
{{% /notice %}}
{{% notice "tip" %}}
Список файлов с прочтениями может быть задан при помощи табулированного manifest-файла.
{{% /notice %}}

### Основные команды для картирования прочтений

Базовые параметры для картирования ридов перечислены ниже (в квадратных скобках показаны опциональные параметры):

`--runRhreadN число_потоков`

`--genomeDir /путь/к/папке/для/хранения_индексов`

`--readFilesIn /путь/к/первому_риду [путь/ко/второму_риду]`

В итоге, типичная команда выглядит следующим образом:

    STAR --runThreadN 12 \
         --readFilesIn ath_seed_sample.fastq \
         --genomeDir ath_star_index

В результате в рабочей директории появится SAM-файл с выравненными прочтениями. Если понадобится выравнить парные прочтения, то команда выглядит так:

    STAR --runThreadN 12 \
         --readFilesIn ath_seed_sample_R1.fastq ath_seed_sample_R2.fastq \
         --genomeDir ath_star_index

STAR не умеет работать со зжатыми файлами. Чтобы открыть их, ему необходимо написать в парметре `--readFilesCommand` команду, при помощи которой он сможет деархивировать файлы. Эта команда должна сгенерировать из входных файлов текст, который будет отправлен в `STDOUT`.

Для чтения файлов `.fastq.gz`, в этой опции нужно указать `--readFilesCommand zcat` или `--readFilesCommand gunzip -c`.

Для чтения файлов `.fastq.bz`, в этой опции нужно указать `--readFilesCommand bzcat` или `--readFilesCommand bunzip2 -c`.

{{% notice "tip" %}}
Команда zcat или bzcat считывает сжатый текстовый файл и выводит в STDOUT, то есть на экран терминала. STAR использует текст из STDOUT как вводные данные.
{{% /notice %}}
{{% notice "tip" %}}
Команды bunzip2 или gunzip деархивируют сжатые файлы и выводит содержимое в STDOUT при наличии опции -c.
{{% /notice %}}

Получается как-то так:

    STAR --runThreadN 12 \
         --readFilesIn ath_seed_sample_R1.fastq.gz ath_seed_sample_R2.fastq.gz \
         --genomeDir ath_star_index \
         --readFilesCommand zcat

Мы можем заставить STAR считывать риды не только из FATQ/FASTA, но также из SAM/BAM-файлов с выравниваниями. Это удобно, когда нужно перекартировать риды на другую сборку генома, для этого нужно указать тип исходного файла в опции `--readFilesType` как `SAM SE` (для односторонних прочтений) или как `SAM PE` (для двусторонних прочтений), а также заставить STAR запустить файл с помощью
`samtools view` (samtools должен быть установлен на устройстве). В таком случае команда будет выглядить так:

    STAR --runThreadN 12 \
         --readFilesIn aligned_SE.bam \
         --readFilesType SAM SE \
         --genomeDir ath_star_index \
         --readFilesCommand samtools view

Обычно мы не работаем с неотсортированными SAM-файлами, а отдаем предпочтение отсортированным BAM-файлам. STAR может сразу выдать результат в таком виде, для этого нужно указать тип выводного файла с выравниванием:

    STAR --runThreadN 12 \
         --readFilesIn ath_seed_sample_R1.fastq.gz ath_seed_sample_R2.fastq.gz \
         --genomeDir ath_star_index \
         --readFilesCommand zcat \
         --outSAMtype BAM SortedByCoordinate

Мы также можем заставить STAR сохранять файлы вывода в папку вне рабочей директории. В таком случае нужно попросить STAR дописывать к названиям файлов префикс, совпадающий с адресом папки назначения при помощи `--outFileNamePrefix`. Этот префикс должен содержать полный адрес директории назначения (заканчивается знаком `/`):

    STAR --runThreadN 12 \
         --readFilesIn ath_seed_sample_R1.fastq.gz ath_seed_sample_R2.fastq.gz \
         --genomeDir ath_star_index \
         --readFilesCommand zcat \
         --outSAMtype BAM SortedByCoordinate \
         --outFileNamePrefix /путь/к_папке/префикс_файла

В примере выше слово “префикс” находится после крайнего слэша `/` и будет первым словом в названии выводных файлов.

Также стоит отметить, что по умолчанию файл с выравниями не будет содержать риды, для которых выравнивания не обнаружилось (или которые не прошли фильтрацию). Чтобы изменить это поведение, нужно воспользоваться параметром `--outSAMunmapped Within`:

    STAR --runThreadN 12 \
         --readFilesIn ath_seed_sample_R1.fastq.gz ath_seed_sample_R2.fastq.gz \
         --genomeDir ath_star_index \
         --readFilesCommand zcat \
         --outSAMtype BAM SortedByCoordinate \
         --outFileNamePrefix /путь/к_папке/префикс_файла \
         --outSAMunmapped Within

А если хочется вывести невыравненные прочтения в отдельный файл, то можно воспользоваться опцией `--outReadsUnmapped Fastx`, благодаря которой риды без выравнивания окажутся в файлах FASTQ/FASTA в зависимости от того, какой изначально тип файла с прочтениями был использован.

{{% expand "Расширенные параметры" %}}

### Выравнивание нескольких файлов с прочтениями в одном запуске команды

Если риды резделены на несколько файлов, то можно перечислить все через запятую. Это эквивалентно конкатенации текстовых файлов, будто мы заставляет STAR соединить несколько файлов с прочтениями в один друг за дружкой:

    --readFilesIn sample1.fq,sample2.fq,sample3.fq 

Если же вы работаете с парными прочтениями, которые разделены на несколько файлов, то можно поступить аналогичным образом, только перечислить файлы для второго рида через пробел:

    --readFilesIn s1read1.fq,s2read1.fq,s3read1.fq s1read2.fq,s2read2.fq,s3read2.fq

Также полезно может быть оставить в выравниваниях информацию о том, из какого конкретно файла пришли прочтения. В таком случае говорят о группе ридов *(read group)*. Если риды взяты из одного файла, то тогда они принадлежат одной группе. Указатель на группу ставится в атрибуте `RG` каждого выравнивания в [SAM-файле](https://samtools.github.io/hts-specs/SAMv1.pdf). Программа STAR будет сопровождать
добавленный атрибут тегом `ID:`. Для этого нужно воспользоваться опцией `--outSAMattrRGline`:

    --outSAMattrRGline ID:sample1 , ID:sample2 , ID:sample3

Обратите внимание, что здесь вы требуете добавить для каждой группы ридов тег ID, в котором будет храниться название исходного файла. Причем разделителем для разных групп является не запятая, а пробел/запятая/пробел.

Вы также можете добавлять дополнительные теги, для каждой группы ридов:

`--outSAMattrRGline ID:xxx , ID:zzz "DS:z z" , ID:yyy DS:yyyy`

Обратите внимание, что для того, чтобы добавить дополнительные теги, нужно обязательно задать название группы с помощью `ID:`, затем перечислять нужные теги через пробел. Если содержимое тега содержит пробелы, нужно писать весь тег в кавычках. Здесь снова нужно разделять записи для каждого образца пробелом/запятой/пробелом.

### Запуск выравнивания прочтений по списку в отельном manifest-файле

Вместо того, чтобы задавать огромный список файлов в командной строке можно просто записать список файлов в таблице так называемого **manifest-файла** при помощи опции

    --readFilesManifest /путь/к/manifest.tsv

Таблица `manifest.tsv` (используйте любое название) состоит из трех столбцов, разделенных табуляцией:

    file1_R1.fq file1_R2.fq строка_тегов1
    file2_R1.fq file2_R2.fq строка_тегов2

В названии файлов разрешены пробелы, но не табуляция. Для случая с односторонними прочтениями вместо второго рида указывается `-`:

    file3_R1.fq - строка_тегов3
    file4_R1.fq - строка_тегов4

Строка тегов может начинаться с префикса `ID:`, в таком случае здесь можно перечислить несколько флагов через табуляцию, добавляя к каждому новому флагу тег по типу `DS:`.

Если в строке тегов нет префикса `ID:`, то тег для группы может быть только однин, префикс `ID:` будет добавлен к нему автоматически.

Все теги будут записаны дословно в строку заголовков `@RG` SAM-файла.

{{% notice "tip" %}}
Можно комбинировать файлы парных и односторонних прочтений в одном запуске.
{{% /notice %}}

### Использование файлов аннотации на этапе выранвивания

Начиная с версии 2.4.1a, аннотацию можно добавлять на лету *(on the fly)* на этапе картирования. При этом не нужно добавлять файл аннотации в геномный индекс. Для этого нужно будет добавить параметр

    --sjdbGTFfile /путь/к/аннотации.gtf 

Также можно добавлять табулированный файл с координатоми сайтов сплайсинга при помощи

    --sjdbFileChrStartEnd /путь/к/сплайс_сайтам.tab,

Дополнительные параметры, начинающиеся с префикса `--sjdb` (см. раздел **Параметры базы экзонных стыков**) могут быть использованы на стадии выравнивания.

Если файл аннотации добавлен на стадии выравнивания, то STAR может модифицировать геномный индекс, просто добавив в него набор аннотированных экзонных стыков. Это занимает 1-2 минуты. Полученный индекс можно сохранить в папке \_STARgenome в директории, откуда была запущена программа, установив параметр

    --sjdbInsertSave All

### Стандартные опции в пайплайне long RNA-seq от ENCODE

`--outFilterType BySJout` - снижает количество редких или ложных экзон-экзонных стыков (“spurious” junctions)

`--outFilterMultimapNmax 20` - максимальное число множественных выравниваний для рида. Если превышено, то рид считается непрокартированным.

`--alignSJoverhangMin 8` - минимальных оверхенг (перекрытие с ридом с одной или другой стороны) для неаннотированных стыков.

`--alignSJDBoverhangMin 1` - минимальное перекритие для аннотированных экзон-экзонных стыков

`--outFilterMismatchNmax 999` -максимлаьное число ошибочных нуклеотидов на пару ридов, большоие значения отключают данный фильтр.

`--outFilterMismatchNoverReadLmax 0.04` - максимальное число замен на пару ридов по относешнию к суммарной длине пары. Если длина ридов 2x100, то число ошибок равно 0.04\*200=8.

`--alignIntronMin 20` - минимальная длина интрона.

`--alignIntronMax 1000000` - максимальная длина интрона.

`--alignMatesGapMax 1000000` - максимальная дистанция между спаренными ридами в геноме.

### Использование разделяемой памяти при обращении к геномным индексам

По умолчанию, геномные индексы загружаются в оперативную память каждый раз при запуске программы в режиме выравнивания. Это требует десятки Gb оперативной памяти. Поэтому создатели сделали возможным обращение к [разделяемой памяти](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B5%D0%BC%D0%B0%D1%8F_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C) (одна из особенностей Linux) для
разных запусков выравнивателя. По сути вы можете один раз загрузить индекс в память, потом обратиться к нему несколько раз, а затем выгрузить оттуда.

Такая возможность реализована через опцию `--genomeLoad LoadAndKeep` (см. раздел **Параметры индексированного генома**). Геном идентифицируется по уникальному пути к директории с индексом. Перед загрузкой STAR проверяет, был ли такой геном загружен в разделяемую память. Если загрузки не происходило, то геном будет загружен, причем STAR может сохранить геном в памяти даже после окончания программы.
Далее геном будет доступен всем остальным процессам, запущеным на устройстве. Чтобы удалить геном из памяти, нужно использовать опцию  
`--genomeLoad Remove`. Удаление произойдет только после того, как все прикрепленные к геному процессы завершатся. Если использовать `--genomeLoad LoadAndRemove`, то STAR загрузит геном в разделяемую память и удалит по окончании процесса. А если воспользоваться  
`--genomeLoad LoadAndExit`, то процесс закончится автоматически, как только геном окажется загружен - никакого выравнивания производиться не будет. Последнее полезно для запуска целого конвеера процессов, которые будут обращаться к одному общему объему памяти.

Создатели программы рекомендуют регулярно выгружать геном из памяти и не оставлять его в раздеялемой памяти надолго, поскольку объекты общей памяти Linux регулярно подвергаются зачистке.

Многие дистрибутивы Linux запрещают использовать большие фрагменты пямяти в режиме общего доступа. Эту проблему можно решить при побощи системного администратора или имея права администратора *(root).* Советуют для этого модифицировать или добавить в файл /etc/sysctl.conf следующие строки:

    kernel.shmmax = Nmax
    kernel.shmall = Nall

**Nmax \> GenomeIndexSize = Genome + SA + SAindex** (31000000000 для генома человека).

**Nall \> GenomeIndexSize/PageSize** (PageSize обычно равно 4096, что можно проверить при помощи команды терминала `getconf PAGE_SIZE`).

В конце нужно запустить команду

    /sbin/sysctl -p

Все это позволит увеличить разрешенный размер блока в разделяемой памяти до 31 Гб, что достаточно для генома человека или мыши.

В итоге, типичный пример использования STAR с разделяемой памятью показан ниже:

    STAR --genomeLoad LoadAndExit --genomeDir $STARINDEX
    for file in $(ls myFastqs/); do
        STAR --runThreadN 5 \
        --readFilesIn $file \
        --genomeDir $STARINDEX \
        --genomeLoad LoadAndKeep
    STAR --genomeLoad Remove --genomeDir $STARINDEX

Обратите внимание, при первом запуске команде STAR передан параметр  
`--genomeLoad LoadAndExit` и директория с индексом. Все последующие запуски сделаны при помощи цикла, причем в каждой команде при помощи опции `--genomeLoad LoadAndKeep` определено обращение к общей памяти и сохранение индекса в ней после завершения выравниваний. Это необходимо, поскольку по умолчанию в STAR действует опция  
`--genomeLoad NoSharedMemory`, из-за чего программа не будет обращаться к общей памяти. Для того, чтобы выгрузить индекс из общей памяти, в завершающей части скрипта запускается STAR с параметром `--genomeLoad Remove`. Поскольку определение индекса происходит по исходной директории с ним, то при каждом запуске программы обязательно нужно указывать путь к индексу.

{{% /expand %}}

### Фильтрация ридов с множественным картированием

Программа STAR обладает обширным списком настроек, контролирующих процесс фильтрации ридов с множественным картированием (когда рид одинаково хорошо выравнивается на несколько локусов генома). По этой причине STAR [советуют](http://www.ncbi.nlm.nih.gov/pmc/articles/PMC4757950) использовать для анализа транскрипционной активности мобильных элементов.

Вывод ридов с множественным выравниванием (multimappers) контролируется через параметр  
`--outFilterMultimapNmax N`. По умолчанию N=10. Если рид выравнивается на число локусов, меньшее или равное заданному то он появится в выравнивании. В ином случае он будет помечен как “Multimapping: mapped to too many loci” в лог-файле `Log.final.out` и будет считаться невыравненным.

Метод детекции ридов с множественным выравниванием контролируется параметром  
`--winAnchorMultimapNmax`. По умолчанию здесь стоит значение 50. Этот параметр должен быть больше или равен `--outFilterMultimapNmax`. Однако от этого параметра зависит общая чувствительность выравнивания: чем он больше, тем дольше программа будет искать уникальные выравнивания.

Число локусов, на которое выравнился рид (Nmap) будет указано в атрибуте SAM-файла NH:i:Nmap. Очевидно, значение Nmap=1 будет соответствовать риду с уникальным картированием. Еще один атрибут `HI` будет использоваться для суммирования множественных вырваниваний рида, если их общее число превышает порог, указанный в параметре `--outSAMattrIHstart`. По умолчанию в этом параметре стоит значение 1,
однако в таких программах как Cufflinks требуется, чтобы порог был равен 0, для чего требуется ввести `--outSAMattrIHstart 0`.

В поле №5 (MAPQ) SAM-файла программа должна указать качество выравнивания. STAR автоматически ставит для ридов с уникальным выравниванием значение 255, а для ридов с множественным выравниванием int\[-10\*lg(1-1/Nmap)\]. Однако для таких программ, таких как GATK, это значение потребуется изменить при помощи параметра `--outSAMmapqUnique` (принимает значение от 0 до 255).

В поле №2 (FLAG) SAM-файла программа должна указать, является ли выравнивание первичным (самым качественным из всех множественных выравниваний) или вторичным (вызывают сомнение, что рид пришел из этого локуса). Для ридов с множественным выравниванием все вырванивания кроме одного будут помечены флагом 0x100 (вторичное выравнивание). Одно случайное выравнивание с лучшей оценкой останенся
непомеченным и будет считаться первичным. Это поведение можно поменять при попощи опции `--outSAMprimaryFlag AllBestScore`, которая заставит программу пометить как первичные все выравнивания с наивысшей оценкой.

По умолчанию, порядок перечисления ридов с множественным выравниваниям не совсем случайный. Опция `--outMultimapperOrder Random` заставит выводить множественные выравнивания в случайном порядке и рандомизирует выбор первичного выравнивания из выборки с самой большой оценкой. Параметр `--runRNGseed` можно использовать для того, чтобы задать начальное значение (seed) генератора случайных чисел. При
одинаковом значении генератора результат выполнения программы будет максимально воспроизводимым. Нужно еще понимать, что использование многопоточного режима неизбежно приводит к отличиям в результатах.

Также может быть полезным ограничить число выводимых выравниваний для ридов с множественным картированием. Это ограничивается параметром `--outSAMmultNmax`. Однако даже если выводить только одно выравнивание, атрибут SAM-файла `NH:i:Nmap` все еще будет показывать точное количество локусов, на которое выравнился рид.

# Результаты выполнения программы

В результате работы STAR выводит несколько файлов. По умолчанию все файлы имеют стандартные названия и будут загружаться в рабочую директорию. Чтобы изменить это поведение, необходимо передать программе префикс к названиям файлов. Это делается при помощи  
`--outFileNamePrefix /путь/к/директории/префикс_в_названии`. Если хотите вывести все возможные выравнивания, передайте параметру `--outSAMmultNmax` значение `-1`.

{{% notice "note" %}}
Обратите внимение, префик содержит как путь к директории назначения, так и первые символы в названии файлов. Если хотите только поменять директорию назначения, то строка префикса должна заканчиваться прямым слэшем.
{{% /notice %}}

### Логи

Программа выводит несколько log-файлов. Это обычные текстовые файлы, в которых содержится информация о запуске.

1.  `Log.out` - это главный лог-файл, в котором перечислена основная информация о запуске программы.

2.  `Log.progress.out` - это файл, в котором перечисляется прогресс выполнения программы. Он обновляется раз в минуту.

3.  `Log.final.out` - это общая статистика по выравниваниям. Как и у других элайнеров, здесь перечисляется, сколько и каким образом выравнилось ридов. Нужно обратить внимание, что парные риды будут считаться за один. Большая часть информации приведена для ридов с уникальным вырваниванием. Уровень замен/инделов пересчитан на основе уникальных выравниваний и нормирован на общее число выравненных на
    геном оснований.

### Файл с выравниваниями

Вы можете вывести [файл с выравниваниями](https://learn.gencore.bio.nyu.edu/ngs-file-formats/sambam-format/) в формате SAM или BAM. В первом случае он будет называться `Aligned.out.sam`. Во втором - `Aligned.out.bam`.

#### Атрибуты в файле выравнивания

Помимо очевидных пунктов, таких как последователность рида, его локации в геноме, файлы выравниваний несут кучу полезной информации как о референсном геноме, так и об отдельных выравниваниях. Вся информация об атрибутах SAM или BAM приведена в [спецификации SAM-файла](https://samtools.github.io/hts-specs/SAMv1.pdf).

STAR позволяет настроить выводимый список атрибутов при помощи опции `--outSAMattributes`. Полный перечень возможных атрибутов указан в разделе **Настройки вывода SAM/BAM**.

#### Совместимость с Cufflinks/Cuffdiff

Программы из семейства Cufflinks требуют, чтобы файлы выравниваний RNA-seq (если транскрипты секвенируются [без сохранения цепи](https://www.azenta.com/blog/stranded-versus-non-stranded-rna-seq)) содержали атрибут `XS`. Cufflinks требует, чтобы этот атрибут присутствовал у любого сплайсированного выравнивания. STAR генерирует этот атрибут с помощью опции `--outSAMstrandField intronMotif`.
Сплайсированные выравнивания, которые имеют неопределенную цепь (то есть неканонические экзон-экзонные стыки) в таком случае будут удалены (suppressed).

Если вы работаете с данными strand-specific RNA-seq, то в таком случае никаких дополнительных опций для STAR вводить не нужно - потребуется запустить Cufflinks с использованием параметра  
`--library-type`.

Создатели STAR рекомендует также удалять риды, перекрывающие неканонические экзон-экзонные стыки, для запусков Cufflinks. Для этого нужно запустить STAR с параметром  
`--outFilterIntronMotifs RemoveNoncanonical`.

#### Вывод файла с выравниваниями в формате BAM и сортировка

В работе часто мы не используем SAM-файлы. Вместо этого мы конвертируем их в BAM, поскольку так файлы занимают меньше места. Кроме того, большинство программ для анализа выравниваний требуют, чтобы выравнивания были отсортированы по координатам. Специально, чтобы пропустить шаг конвертации SAM в BAM, а также сортировку (обычно делается при помощи `samtools sort`), авторы STAR внедрили в свою
программу два этих шага.

Заставить STAR выводить несортированный BAM-файл можно при помощи опции `--outSAMtype BAM Unsorted`. В таком случае в директории появится файл `Aligned.out.bam`. Его можно дальше передать программе HTseq. Порядок ридов в таком несортированном файле будет точно соответсвовать порядку ридов в начальном файле FASTQ/FASTA.

Чтобы вывести сортированный BAM-файл, нужно ввести `--outSAMtype BAM SortedByCoordinate`. Тогда будет получен файл `Aligned.sortedByCoord.out.bam`. Это аналогично использованию `samtools sort`. Если сортировка таким образом вызывает ошибку, то рекомендуется понизить число потоков, которые используются при сортировке, при помощи `--outBAMsortingThreadN` (по умолчанию шесть потоков).

Если требуется вывести и сортированный и несортированный файл, то нужно ввести `--outSAMtype BAM Unsorted SortedByCoordinate`.

### Вывод невыравненных прочтений

По умолчанию невыравненные риды (не удовлетворяющие параметрам фильтрации) будут проигнорированы. Если вы хотите вывести такие риды в основной файл с выравниваниями, то используйте опцию `--outSAMunmapped Within`. Если вы хотите вывести такие риды в отдельный файл с прочтениями (FASTQ/FASTA), то используйте `--outReadsUnmapped Fastx`.

Более подробно об этих опциях можно прочитать в разделе **Настройки вывода SAM/BAM** и **Общие настройки вывода**.

### Сайты сплайсинга

STAR выводит информацию о достоверных сайтах сплайсинга в файл `SJ.out.tab`. Нужно обратить внимание, что точка разрыва сшивки программой STAR определяется по крайнему нуклеотиду в интроне.

{{% expand "Описание SJ.out.tab" %}}

В файле SJ.out.tab 9 колонок:

1.  Название хромосомы

2.  Первый нуклеотид в интроне (в системе 1-based, где первый нуклеотид на хромосоме имеет номер 1)

3.  Последний нуклеотид в интроне (в системе 1-based)

4.  Цепь (0: неопознана, 1: +, 2: -)

5.  Интронный мотив (0: неканоничный; 1: GT/AG, 2: CT/AC, 3: GC/AG, 4: CT/GC, 5: AT/AC, 6: GT/AT)

6.  Тип аннотации (0: ранее неаннотирован; 1: присутствовал в базе сплайс-сайтов)

7.  Число уникально картированных прочтений, пересекавших стык между экзонами

8.  Число прочтений со множественным выравниванием, пересекавших стык между экзонами

9.  Максимальный оверхенг вокруг стыка (число оснований внутри рида с одной или другой стороны от стыка)

{{% /expand %}}

Филтровать данные для этого файла можно при помощи параметра `--outSJfilter`. Подробности в разделе **Фильтрация слайс-сайтов**.

Если хотите сохранить эту таблицу в файл с другим названием, можно восопльзоваться опцией `--sjdbFileChrStartEnd /путь/к/сплайс_сайтам.tab`

Для более чувствительного поиска сплайс-сайтов в STAR реализован режим двойного выравнивания (2-pass mode). Его можно включить при помощи опции `--twopassMode Basic`. В этом случае программа сначала выравнит заданное параметром `twopass1readsN` число ридов, чтобы предварительно подобрать сайты сплайсинга, а затем проведет 2й раунд (2nd pass) выравнивания, в котором уже все риды будут выравнены на
геном с учетом положения ранее выявленных сайтов сплайсинга. Если двойное выравнивание включено, то обнаруженные на первом этапе сайты сплайсинга (в доволнение к имеющимся в GTF-файле) будут считаться аннотированными (6 колонка в файле). Подробности режима двойного выравнивания можно прочитать в разделе **Двухкратное картирование ридов для аннотации сайтов сплайсинга.**

### Вывод химерных выравниваний

STAR может детектировать химерные выравнивания в дополнению к обычным выравниваниям. Химерными считаются такие выравнивания, когда части ридов либо лежат слишком далеко, либо неправильно ложатся смысловую и антисмысловую часть ДНК (при каноническом сплайсинге спаренные риды должны быть на разных цепях ДНК, а части сплайсированного рида должны лежать на одной цепи ДНК), либо когда части ридов
ложатся на разные хромосомы.

Создатели STAR определили химерные выравнинвания как выравнивания из двух нехимерных сегментов, причем сегменты должны лежать относительно друг друга как части химерной молекулы. Оба сегмента могут содержать сайты сплайсинга. Кроме того, один из сегментов может содержать фрагменты обоих спаренных ридов (т.е. риды перекрываются).

В последних версиях STAR поиск химерных выравниваний начинается, если разница оценки выравнивания у лучшего нехимерного выравнивания (с учетом мягкой обрезки) и лучшего сквозного выравнивания цельного рида больше чем число, указанное в `--chimNonchimScoreDropMin` (по умолчанию 20).

Парметр `--chimSegmentMin` контролирует минимальную длину двух сегментов. Например, для 2x75 прочтений, если `--chimSegmentMin` равен 20, то химерное выравнивание длиной 130 пар на одной хромосоме и 20 на другой хромосоме будет считаться химерным, тогда как выравнивание 135+15 не будет считаться химерным и будет удалено.

По умолчанию химерные выравнивания выводятся в табулированный файл `Chimeric.out.junction`.

{{% expand "Описание Chimeric.out.junction" %}}

`Chimeric.out.junction` представляет из себя таблицу, как показано ниже:

        chr22   23632601    +   chr9    133729450   +   1   0   0   SINATRA-0006:3:3:6387:5665#0    23632554    47M29S  133729451   47S29M40p76M

Описание колонок:

1.  Хромосома донор (идет левее).

2.  Позиция первого нуклеотида донорного сайта в “интроне” (1-base).

3.  Цепь донора.

4.  Хромосома акцептора.

5.  Позиция первого нуклеотида акцепторного сайта в “интроне” (1-base).

6.  Цепь акцептора.

7.  Тип соединения (-1: соединение лежит между спаренными ридами *(encompassing)*; 1: GT/AG; 2: CT/AC).

8.  Длина повтора слева от стыка.

9.  Длина повтора в правой части стыка.

10. Идентификатор рида.

11. Позиция первого нуклеотида в первом сегменте (считается по + цепи).

12. [CIGAR-строка](https://drive5.com/usearch/manual/cigar.html) для первого сегмента.

13. Позиция первого нуклеотида во втором сегменте.

14. CIGAR-строка для второго сегмента.

Колонки 15-20 дают информацию об оценке выравнивания и важных метаданных. Эти колонки выводятся в случае, если алгоритму выравнивания позволено искать множественные химерные выравнивания (параметр `--chimMultimapNmax` болше 0). Обнаруженные выравнивания будут отличаться по величине оценки за выравнивания. Только множественные выравнивания, чья оценка отличается от максимальной среди всех на
величину, не превышающую `--chimMultimapScoreRange`, будут выводиться в итоговый файл.

15. Число химерных выравниваний для данного фрагмента, которые обладали достаточной оценкой.

16. Максимально возможная оценка за выравнивания для данного фрагмента.

17. Оценка за лучшее нехимерное выравнивание.

18. Оценка за указанное в столбцах 1-9 индивидуальное химерное выравнивание.

19. Высшая оценка за химерное выравнивание среди всех выравниваний для данного фрагмента.

20. Логическое значение. Указывает, были ли перекрывающиеся спаренные риды слиты в одну последовательность ДНК перед картированием.

21. Последний столбец, указывает на то, к какой группе принадлежат риды.

В этом файле оба прочтения перечислены в одной строке, тогда как в SAM-файле в разных. Промежуток между спаренными ридами L указавается вслед за флагом p в строке CIGAR. Если спаренные риды пересекаются, то L\<0.

При выравнивании двусторонних прочтений, последовательность второго рида в паре указана обратно-комплементарно.

Для случаев, когда стыки между фрагментами геномных последовательностей не перекрываются ридами *(encompassing junctions)*, т.е. когда тип соединения равен -1, колонка 2 и 5 представляет границы локуса, внутри которого находится стык. Для первого рида в паре это будет нуклеотид, который находится левее 3\\‘-концевого основания в риде. Для второго рида в паре это будет нуклеотид, который
предшествует 5\\’-концевому основанию.

Вы можете отфильтровать химерные стыки и найти число ридов, которые на них лежат (supporting reads) при помощи следующего набора команд:

        cat Chimeric.out.junction |
        awk ’$1!="chrM" && $4!="chrM" && $7>0 && $8+$9<=5 {print $1,$2,$3,$4,$5,$6,$7,$8,$9}’ |
        sort | uniq -c | sort -k1,1rn

Эта команда сохранит только канонические стыки с длиной повтора короче 5 и удалит химеры с митохондриальной ДНК.

{{% /expand %}}

Вы можете выводить химерные выравнивания в основной файл с выравниваниями, указав параметр `--chimOutType WithinBAM.`.

Вы также можете вывести химерные выравнивания в отдельный SAM-файл `--chimOutType SeparateSAMold` - появится файл `Chimeric.out.sam`. Однако некоторые риды могут выводиться как в основной файл выравниваний, так и в химерный. Так происходит в тех случаях, если для рида есть два хороших выравнивания, причем одно из них химерное.

#### Программа STAR-Fusion

Создатели STAR также создали программу для детекции химерных транскриптов среди выравниваний STAR. Она доступна в [репозитории GitHub](https://github.com/STAR-Fusion/STAR-Fusion).

### Вывод выравниваний, попадающих внутрь генов

Используя опцию `--quantMode TranscriptomeSAM`, вы можете заставить STAR выводить только риды, которые выравниваются на аннотированные гены. В результате появится файл `Aligned.toTranscriptome.out.bam`. Это может быть полезно для вычисления экспрессии генов при помощи таких программ как RSEM или eXpress.

Алгоритм STAR в любом случае будет выравнивать риды на весь геном, а только после этого будет искать риды внутри генов. Пэтому в режиме `--quantMode TranscriptomeSAM` параметр `--outFilterMultimapNmax` (устанавливает максимальное число локусов, на которое может выравниваться рид) будет применен на стадии вырванивания на весь геном. Так что только те риды, которые проходят данный фильтр и попадают
в гены, будут выводиться.

Нужно иметь в виду, что по умолчанию в этом режиме STAR будет выводить риды, удовлетворяющие параметрам RSEM: мягкая обрезка или инделы запрещены. Чтобы изменить это поведение, нужно воспользоваться оцпией `--quantTranscriptomeBan Singleend`. Это может понадобиться для других программ, таких как eXpress.

### Подсчет числа прочтений на ген

Одна из задач RNA-seq - количественная оценка активности генов. Это делается путем подсчета числа прочтений внутри каждого гена. Обычно для этого используются специальные программы, которые принимают файл выравниваний и файл с геномной аннотацией, чтобы посчитать число прочтений в заданных генах (FeatureCounts, HTseq-count и пр.). STAR разработан специально, чтобы избежать дополнительных
упражнений с результатами и позволяет сразу вычислать число прочтений в генах.

Чтобы заставить STAR считать прочтения, нужно воспользоваться опцией `--quantMode GeneCounts`. Риды будут подсчитаны в том случае, если они пересекают ген (на 1 нуклеотид или более, как укажете). Оба конца спаренных ридов будут проверяться на предмет пересечения с геном. В результате вы получите файл с числом прочтений на ген, аналогичный результату работы HTseq-count в стандартном режиме.
Использование этой опции возможно только в том случае, если файл аннотации в формате GTF был добавлен г индесу или на стадии выравнивания при помощи опции `--sjdbGEGfile`.

В результате будет получен файл `ReadsPerGene.out.tab`.

{{% expand "Описание ReadsPerGene.out.tab" %}}

Файл представляет собой таблицу с 4 столбцами:

1.  Идентификатор гена

2.  Число прочтений для unstranded RNA-seq

3.  Число прочтений для случая, когда первый рид лежит на той же цепи, что и ген (аналог htseq-count -s yes)

4.  Число прочтений для случая, когда второй рид лежит на той же цепи, что и ген (аналог htseq-count -s reverse)

Выбирать строку нужно в зависимости от того, каким образом была проведена пробоподготовка RNA-seq. Если направление прочтений соответствует направлению гена (unstranded), то нужно выбрать 2 столбец. В противном случае - 3 или 4.

{{% /expand %}}

Если поставить опцию `--quantMode TranscriptomeSAM GeneCounts`, то будут выведены файлы Aligned.toTranscriptome.out.bam и ReadsPerGene.out.tab.

### 2х-кратное картирование

Изначальная идея 2-хкратного картирования заключалается в следующем.

Для эксперимента, в котором будет проанализировано несколько образцов, советуют делать анализ в два этапа:

1.  Выравнить каждый образец на геном, чтобы получить таблички с обнаруженными в ходе выравнивания сайтами сплайсинга.

2.  Запустить выравнивание для каждого образца еще раз, только на этот раз перечислить аннотированные на первом этапе сайты сплайсинга с помощью `--sjdbFileChrStartEnd`:

         --sjdbFileChrStartEnd /path/to/sj1.tab /path/to/sj2.tab ....

Чтобы не делать одну и ту же работу дважды, создатели STAR внедрили в программу возможность двойного картирования (2-pass mode), который включается при помощи опции `--twopassMode Basic`. Суть в том, что на первом этапе программа выравнивает заданное параметром `twopass1readsN` число ридов, чтобы предварительно подобрать неаннотированные сайты сплайсинга. На втором круге выравнивания (2nd pass), в
котором уже все риды будут выравнены на геном с учетом положения ранее выявленных интронов.

В более старых версиях STAR (до 2.4.1а) алгоритм 2х-кратного картирования отличался тем, что после первого прогона пользователю приходилось перезаписывать индексированный геном, добавляя в него новый файл с координатами экзон-экзонных стыков.

### Слияние перекрывающихся спаренных ридов

Для того, чтобы увеличить точность картирования, в STAR реализована возможность автоматического слияния (merging) спаренных ридов. Это возможно, когда длина фрагмента ДНК, фланкированного секвенирующими адаптерами, оказывается меньше чем суммарная длина ридов. Например, в запуске 2x75 риды будут перекрываться для всех фрагментов короче 150 bp.

Чтобы заставить STAR сливать риды, нужно указать минимальную область пересечения в параметре `--peOverlapNbasesMin` и долю возможных замен в области перекрывания в `--peOverlapMMp`. Если перекрывание обнаружено, то STAR сливает два рида в одноцепочечную последовательность, которую будет пытаться выравнить на геном. Если такие слитые последовательности не выравниваются, то риды будут выравниваться
отдельно друг от друга.

### Выравнивание с учетом мутантных вариантов

В некоторых случаях исследователям требуется вычислять экспрессию аллель-специфичных транскриптов. Один из вариантов такого анализа - добавить информацию об аллельном происхождении прочтения непосредственно в файл с выравниваниями.

Чтобы сделать это, вы можете добавить [VCF-файл](https://samtools.github.io/hts-specs/VCFv4.2.pdf) с перечисленными мутацианными вариантами на стадии выравнивания. Для этого нужно добавить адрес к VCF-файлу в опцию `--varVCFfile /путь/к/vcf/файлу` . В версии 2.7.10b возможен анализ только однонуклеотидных вариантов (SNV). Каждый SNV должен иметь два аллельных варинта. Варианты, которые
перекрываются с выравниванием, будут добавлены в атрибуты SAM-файла `vG` (геномная координата) и `vA` (собственно тип аллеля: 1 - аллель один, 2 - аллель два, 3 - ни один аллель не совпал). Нужно обязательно проконтролировать, чтобы эти атрибуты присутствовали в списке параметра `--outSAMattributes`.

#### Фильтрация аллель-специфичных выравниваний при помощи WASP

Чтобы дать пользователям возможность исследовать аллель-специфичную экспрессию, создатели добавили в STAR алгоритм \[WASP\] (<https://www.nature.com/articles/nmeth.3582>) для фильтрации аллель-специфичных прочтений. Она включается при помощи опции `--waspOutputMode SAMtag`.

После включения WASP в итоговом SAM-файле появится атрибут `vW` с несколькими возможными значениями: vW:i:1 - выравнивание прошло фильтрацию WASP vW:i:2 - рид имеет множество выравниваний vW:i:3 - вырожденный нуклеотид N (неизвестно, каким нуклеотидом представлен аллель) vW:i:4 - после повторного картирования рид не выравнивается vW:i:5 - после повторного картирования рид имеет несколько
выравниваний vW:i:6 - после повторного картирования рид выравнивается на другой локус vW:i:7 - рид перекрывает слишком много геномных варинатов

# Выравнивание на консенсусный геном при помощи STARconsensus

В версии 2.7.7а создатели внедрили алгоритм **STARconsensus**, который предназначался для выравнивания ридов на индекс с учетом замен, предложенных в VCF-файле (consensus mapping). Это позволяло учесть как SNV, так и инделы.

Работает это следующим образом:

У вас на руках должен быть референсный геном (FASTA-файл), \[опционално\] файл с аннотированными генами или \[опционално\] таблица сплайс-сайтов, а также [VCF-файл](https://samtools.github.io/hts-specs/VCFv4.2.pdf) с перечисленными консенсусными геномными вариантами. Используя все это вы индексируете геном в режиме `--runMode genomeGenerate`. Чтобы добавить VCF-файл, нужно использовать параметр
`--genomeTransformVC /путь/к/VCF`, и указываете метод трансформации референса `--genomeTransformType Haploid`:

STAR –runThreadN 12   –runMode genomeGenerate   –genomeDir /директория/для/будущего/индекса/   –genomeFastaFiles /путь/к/референсу.fa  
–sjdbGTFfile /файл/с/аннотацией.gtf  
–sjdbFileChrStartEnd /путь/к/сплайс_сайтам.tab  
–genomeTransformVC /путь/к/VCF  
–genomeTransformType Haploid –sjdbOverhang 149

Во время индексации STAR использует VCF-файл, чтобы модифицировать референс, и в результате получит трансформированный геном. Координаты генов тоже могут поменяться (из-за инделов), так что файл с аннотация тоже будет трансформирована.

На стадии картирования все риды будут выравнены уже на трансформированный геном. Вы можете посчитать экспрессию генов при помощи стандартной опции `--quantMode TranscriptomeSAM` и/или `GeneCounts`. Если нужно, то полученные выравнивания или сплайс-соединения (файл `SJ.out.tab`) могут быть трансформированы в обратно к координатам изначального референса при помощи `--genomeTransformOutput SAM`,
`--genomeTransformOutput SJ` или `--genomeTransformOutput SAM SJ`.

# STARsolo для картирования, думультиплексирования и квантификации генов в single cell RNA-seq

С появлением технологий scRNA-seq, возникла необходимость в создании алгоритмов, специлизированных на обработки соответствующих транскриптомных данных. Разные платформы предлагают различные стратегии секвенирования транскриптома в масштабе единичных клеток, хотя общяя идея везде одна: добавить к секвенирующим адаптерам участки с вырожденной последовательностью (т.е. баркоды) таким образом, чтобы
все прочтения, полученные из одной клетки, обладали уникальным баркодом. Помимо клеточных баркодов в адаптеры добавляют UMI - еще один баркод, уникальный для фрагмента ДНК. Если два рида имеют одинаковый UMI и клеточный баркод, то можно с уверенностью утверждать, что они являются ПЦР-дупликатами.

STARsolo представляет собой набор параметров, которые позволяют за один запуск программы решить несколько задач: выравнить риды на геном, определить принадлежность рида к клетке, определить среди ридов ПЦР дупликаты (провести демультиплексирование/дедупликацию при помощи UMI), посчитать экспрессию каждого гена в каждой клетке.

Из-за того, что секвенатор может совершать ошибки при прочтении нуклеотидов, а также из-за того, что ошибки могут возникать на стадии амплификации библиотек, STAR использует алгоритм коррекции ошибок (включает несколько параметров фильтрации), чтобы точно идентифицировать уникальные клеточные баркоды и UMI.

Алгоритм STARsolo заимствует много вещей у [10x CellRanger](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/what-is-cell-ranger), так что может служить ествественной заменой этой программе.

Список опций для запуска STARsolo указан в разделе **Параметры STARsolo (для анализа cingle cell RNA-seq)**, а подробное описание процедуры анализа scRNA-seq дано на [странице создателей в GitHub](https://github.com/alexdobin/STAR/blob/master/docs/STARsolo.md)

# Конвертация GTF-файлов между геномными сборками

В инструкции к STAR указано, что в программе есть алгоритм [конвертации собрки](https://genviz.org/module-01-intro/0001/06/02/liftoverTools/) (liftOver). Подробного объяснения не дается, однако какието-вещи даны в описаниях к параметрам.

Для конвертации GTF-файла из сборки (например, dm3 в сборку dm6), требуется [chain-файл](https://genome.ucsc.edu/goldenpath/help/chain.html), в котором приведено попарное вырванивание координат в разных геномных сборках. Скачать chain-файлы можно, например, с [ftp-репозитория UCSC](http://hgdownload.soe.ucsc.edu/downloads.html). Обратите внимание, что ссылка на chain-файлы (LiftOver files) здесь
дана отдельно для каждого организма. Кроме того, chain-файлы будут отличаться в зависимости от направления конвертации. Напремер, для конвертации dm3 в dm6 нужен файл `dm3ToDm6.over.chain.gz`, а при обратной конвертации `dm6ToDm3.over.chain.gz`.

Далее у нас есть файл аннотации GTF для dm3, и чтобы перевести его в dm6 нужно ввести следующее:

    STAR --runMode liftOver \
          --sjdbGTFfile /путь/к/dm3.gtf
          --genomeChainFiles /путь/k/dm3ToDm6.over.chain.gz
          --readFilesCommand zcat

Обратите внимание, так как STAR не умеет читать сжатые файлы, скорее всего придется воспользоваться опцией –readFilesCommand. По идее, в рабочей директории будет создан файл GTF, конвертированный под сборку dm6.

# Создание профиля покрытия из выравниваний

Также в описании к программе STAR есть пункты о возможности создать профиль покрытия (signal file, аналог [DeepTools bamCoverage](https://deeptools.readthedocs.io/en/develop/content/tools/bamCoverage.html)). Информации об этом мало, какая-то информация дана [в оригинальной статье про STAR](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4631051/), но судя по всему нужно сделать следующее:

    STAR --runMode inputAlignmentsFromBAM \
          --outWigType wiggle | bedGraph | bedGraph read1_5p | bedGraph read2 \
          --readFilesIn /путь/к/bam_или_sam-файлу \
          [--outWigStrand Stranded |Unstranded] \
          [--readFilesCommand samtools view] \
          [--outWigNorm RPM | None]

Здесь альтернативные значения параметров указаны через прямую черту `|`. Необязательные параметры (но я не уверен, что они необязательны) указаны в квадратных скобках.

Подробнее о параметрах профиля покрытия можно узнать в разделе **Вывод профиля покрытия в формате Wiggle или BedGraph**.

# Полный список параметров

{{% notice "warning" %}}
Список параметров приведен в соответсвии с версией программы 2.7.10b.
{{% /notice %}}

### Файл с параметрами

<table>
<colgroup>
<col style="width: 30%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--parametersFiles</code></td>
<td><code>-</code></td>
<td><p><strong>путь к файлу</strong></p>
<p>Путь к файлу со списком заданных параметров для запуска в командной строке. “-” - путь по умолчанию, соответсвует
<a href="https://github.com/alexdobin/STAR/blob/master/source/parametersDefault">файлу</a> <code>parametersDefault</code> в папке <code>source</code> в директории с
программой STAR</p></td>
</tr>
</tbody>
</table>

### Выбор системной оболочки

<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 39%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--sysShell</code></td>
<td><code>-</code></td>
<td><p><strong>путь к бинарному файлу</strong></p>
<p>Путь к интерпретатору оболочки в Unix-системе. “-” - путь по умолчанию в системе (обычно <code>/bin/sh</code> или <code>/bin/bash</code>). Указывается только при возникновении
ошибки в некоторых системах Linux.</p></td>
</tr>
</tbody>
</table>

### Режим работы программы

<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 35%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--runMode</code></td>
<td><code>alignReads</code></td>
<td><p><strong>строка</strong></p>
<p>Определяет режим работы программы:</p>
<p><code>alignReads</code> - картирование прочтений на референс;</p>
<p><code>genomeGenerate</code> - индексирование референса;</p>
<p><code>in putAlignmentsFromBAM</code> - генерирует профиль покрытия на основе выравненного BAM-файла. Работает только с параметрами <code>--outWigType</code> и
<code>--bamRemoveDuplicates</code>;</p>
<p><code>liftOver</code> - конвертирует GTF-файл (заданный параметром <code>--sjdbGTFfile</code>) между версиями геномных сборок при помощи файла <code>--genomeChainFiles</code>;</p>
<p><code>soloCell Filtering &lt;папка с посчитанными прочтениями&gt; &lt;путь для  записи отфильтрованных префиксов&gt;</code> - запускает фильтрацию баркодированных прочтений
scRNA-seq без перевыравнивания при помощи <strong>STARsolo</strong></p></td>
</tr>
<tr class="even">
<td><code>--runThreadN</code></td>
<td><code>1</code></td>
<td><p><strong>целое число</strong></p>
<p>Число потоков</p></td>
</tr>
<tr class="odd">
<td><code>--runDirPerm</code></td>
<td><code>User_RWX</code></td>
<td><p><strong>строка</strong></p>
<p>Разрешения на запись, чтение, удаление файлов во время работы программы</p>
<p><code>User_RWX</code> - user-read/write/execute (доступ только для юзера)</p>
<p><code>All_RWX</code> - all-read/write/execute (аналог chmod 777, доступ для всех)</p></td>
</tr>
<tr class="even">
<td><code>--runRNGseed</code></td>
<td><code>777</code></td>
<td><p><strong>целое число</strong></p>
<p>Зерно для генератора случайных чисел. Два одинаковых запуска программы с разным зерном дадут немного различающиеся результаты.</p></td>
</tr>
</tbody>
</table>

### Параметры индексированного генома

<table>
<colgroup>
<col style="width: 37%" />
<col style="width: 31%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--genomeDir</code></td>
<td><code>./GenomeDir/</code></td>
<td><p><strong>путь к директории</strong></p>
<p>Путь к директории с индексированным геномом. В режиме <code>generateGenome</code> индексы будут записаны сюда. В режиме <code>alignReads</code>
индексы будут искаться здесь.</p></td>
</tr>
<tr class="even">
<td><code>--genomeLoad</code></td>
<td><code>NoSharedMemory</code></td>
<td><p><strong>строка</strong></p>
<p>Порядок действий с <a href="http%20s://ru.w%20ikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B5%D0%BC%D0%B0%D1%8F_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C">разделяемой
памятью</a>
при использовании файлов генома. Разделяемая память позволяет нескольким запущенным программам STAR обращаться к одному
разделу памяти, сократив время запуска программы. Используется только в режиме <code>alignReads</code>, когда планируется делать
несколько запусков программы.</p>
<p><code>LoadAndKeep</code> - загрузить геном в общую память и хранить там после окочания программы.</p>
<p><code>LoadAndRemove</code> - загрузить геном в общую память и удалить после окончания программы</p>
<p><code>LoadAndExit</code> - загрузить в общую память и сразу выйти. Хранить в памяти до последующих запусков.</p>
<p><code>Remove</code> - не картировать ничего, только удалить загруженный в память геном</p>
<p><code>NoSharedMemory</code> - не использовать общую память</p></td>
</tr>
<tr class="odd">
<td><code>--genomeFastaFiles</code></td>
<td><code>-</code></td>
<td><p><strong>адрес файла</strong></p>
<p>Путь к FASTA-файлам с референсными последовательностями генома. <strong>Файлы не могут быть сжатыми.</strong> Обязательно указывается в
режиме <code>generateGenome</code>. В режиме <code>alignReads</code> позволяет добавить дополнительные последовательности к индексированному
референсному геному (например spike-in контроли в RNA-seq)</p></td>
</tr>
<tr class="even">
<td><code>--genomeChainFiles</code></td>
<td><code>-</code></td>
<td><p><strong>адрес файла</strong></p>
<p>Путь к <a href="https://genome.ucsc.edu/goldenPath/help/chain.html">.chain</a> файлу для
<a href="https://genviz.org/module-01-intro/0001/06/02/liftoverTools/">конвертации</a> <em>(lift-over)</em> GTF между версиями сборки
генома. Используется только в режиме <code>liftOver</code>.</p></td>
</tr>
<tr class="odd">
<td><code>--genomeFileSizes</code></td>
<td><code>0</code></td>
<td><p><strong>целое число</strong></p>
<p>Точные размеры индексов в байтах. Не используется юзерами.</p></td>
</tr>
<tr class="even">
<td><code>--genomeTransformOutput</code></td>
<td><code>None</code></td>
<td><p><strong>строка</strong></p>
<p>Используется при картировании RNA-seq ридов на <em>консенсусный геном</em> алгоритмом <strong>STARconsensus</strong>, когда результирующие
координаты выравниваний или экзонных-стыков сдвигаются. При необходимости можно заставить программу трансформировать
результирующие координаты в исходные, соотвествующие изначальному референсу.</p>
<p>Варианты: <code>SAM</code>,<code>SJ</code>, <code>SAM SJ</code> или <code>None</code></p></td>
</tr>
<tr class="odd">
<td><code>--genomeChrSetMitochondrial</code></td>
<td><code>chrM M MT</code></td>
<td><p><strong>строка</strong></p>
<p>Названия митохондриальных хромосом. Испольуется только для вывода статистики алгоритмом <strong>STARsolo</strong>.</p></td>
</tr>
</tbody>
</table>

### Параметры индексирования генома в режиме `genomeGenerate`

<table>
<colgroup>
<col style="width: 45%" />
<col style="width: 27%" />
<col style="width: 27%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--genomeChrBinNbits</code></td>
<td><code>18</code></td>
<td><p><strong>целое число</strong></p>
<p>При хранении генома каждая хромосома будет занимать целое число бинов. Параметр определяет размер бина
через показательную функцию log<sub>2</sub>(chrBin). При работе с геномами, в которых большое число контигов, этот
параметр нужно снизить. Если обозначить длину генома за <em>L</em>, число последовательностей в референсном
геноме за <em>N</em>, а длину рида за <em>l</em>, то наилучшим значением для этого параметра будет min(18,
log<sub>2</sub>[max(<em>L</em>/<em>N</em>,<em>l</em>)]).</p></td>
</tr>
<tr class="even">
<td><code>--genomeSAindexNbases</code></td>
<td><code>14</code></td>
<td><p><strong>целое число</strong></p>
<p>Длина преиндексированной строки в дереве суффиксов <em>(SA)</em>. Обычно между 10 и 15. Более длинные строки
требуют больше памяти, но ускоряют поиск. Для маленьких геномов (меньше 1Gb) должнобыть уменьшено согласно
формуле:</p>
<p>min(14, log<sub>2</sub>(<em>L</em>)/2 - 1), где <em>L</em> - длина генома.</p></td>
</tr>
<tr class="odd">
<td><code>--genomeSAsparseD</code></td>
<td><code>1</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Разряженность <em>(sparsity)</em> дерева суффиксов, ака дистанция между индексированными суффиксами. Чем больше
число, тем меньше требования к оперативной памати, но медленнее выравнивание.</p></td>
</tr>
<tr class="even">
<td><code>--genomeSuffixLengthMax</code></td>
<td><code>-1</code></td>
<td><p><strong>целое число</strong></p>
<p>максимальная длина суффиксов. Должна быть больше длины ридов. Значение <code>-1</code> означает бесконечность.</p></td>
</tr>
<tr class="odd">
<td><code>--genomeTransformType</code></td>
<td><code>None</code></td>
<td><p><strong>строка</strong></p>
<p>Тип трансформации генома:</p>
<p><code>None</code> - нет трансформации;</p>
<p><code>Haploid</code> - заменает референсные аллели альтернативными вариантами из VCF-файла (на консенсус)</p>
<p><code>Diploid</code> - создает два гаплотипа для каждой хромосомы в VCF-файле. Предполагает идеальное фазирование
между геномами, то есть что пары гаплотипов соответствуют отцу и матери.</p></td>
</tr>
<tr class="even">
<td><code>--genomeTransformVCF</code></td>
<td><code>-</code></td>
<td><p><strong>путь к файлу</strong></p>
<p>Путь к VCF-файлу для трансформации генома</p></td>
</tr>
</tbody>
</table>

### Параметры базы экзонных стыков (Splice Junctions)

<table>
<colgroup>
<col style="width: 44%" />
<col style="width: 27%" />
<col style="width: 27%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--sjdbFileChrStartEnd</code></td>
<td><code>-</code></td>
<td><p><strong>путь к файлу</strong></p>
<p>Путь к файлу с геномными координатами экзон-экзонных стыков. Может быть несколько файлов, перечисленных
через пробел.</p></td>
</tr>
<tr class="even">
<td><code>--sjdbGTFfile</code></td>
<td><code>-</code></td>
<td><p><strong>путь к файлу</strong></p>
<p>Путь к GTF-файлу с аннотацией генома.</p></td>
</tr>
<tr class="odd">
<td><code>--sjdbGTFchrPrefix</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>префикс в начале имени хромосомы в GTF-файле. Как правило это <strong>“chr”</strong>. Может пригодиться при
использовании аннотации ENSEMBL и референса UCSC.</p></td>
</tr>
<tr class="even">
<td><code>--sjdbGTFfeatureExon</code></td>
<td><code>exon</code></td>
<td><p><strong>строка</strong></p>
<p>Тип объекта <em>(feature)</em> в <a href="https://www.ensembl.org/info/website/upload/gff.html">GTF-файле</a>, который будет
использоваться в качестве экзонов при построении транскриптов.</p></td>
</tr>
<tr class="odd">
<td><code>--sjdbGTFtagExonParentTranscript</code></td>
<td><code>transcript_id</code></td>
<td><p><strong>строка</strong></p>
<p>Название атрибута в GTF-файле, который будет использоваться качестве идентификатора <em>(ID)</em> порождающего
транскрипта <em>(parent transcript).</em></p></td>
</tr>
<tr class="even">
<td><code>--sjdbGTFtagExonParentGene</code></td>
<td><code>gene_id</code></td>
<td><p><strong>строка</strong></p>
<p>Название атрибута в GTF-файле, который будет использоваться качестве идентификатора <em>(ID)</em> порождающего
гена <em>(parent gene).</em></p></td>
</tr>
<tr class="odd">
<td><code>--sjdbGTFtagExonParentGeneName</code></td>
<td><code>gene_name</code></td>
<td><p><strong>строка</strong></p>
<p>Название атрибута в GTF-файле, который будет использоваться качестве названия <em>(name)</em> порождающего гена
<em>(parent gene).</em></p></td>
</tr>
<tr class="even">
<td><code>--sjdbGTFtagExonParentGeneType</code></td>
<td><code>gene_type gene_biotype</code></td>
<td><p><strong>строка</strong></p>
<p>Название атрибутов в GTF-файле, который будет использоваться качестве типа (белок-кодирующий, некодирующий
и пр.) порождающего гена <em>(parent gene type).</em></p></td>
</tr>
<tr class="odd">
<td><code>--sjdbOverhang</code></td>
<td><code>100</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>длина донорской/акцепторной последовательности с каждой стороны экзон-экзонного стыка. В идеале должно быть
на 1 короче длины рида.</p></td>
</tr>
<tr class="even">
<td><code>--sjdbScore</code></td>
<td><code>2</code></td>
<td><p><strong>целое число</strong></p>
<p>Дополнительный бонус за выравнивание <em>(extra alignment score)</em>, которое пересекает базу экзонных стыков.</p></td>
</tr>
<tr class="odd">
<td><code>--sjdbInsertSave</code></td>
<td><code>Basic</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает, какие файлы сохранять, когда информация об экзонных стыках добавляется на стадии выравнивания:</p>
<p><code>Basic</code> - только малые стыки/файлы с транскриптами</p>
<p><code>All</code> - все файлы, включая дополнительные файлы индексов. По сути это создаст измененную копию геномного
индекса в папке, из которой была запущена программа.</p></td>
</tr>
</tbody>
</table>

### Добавление геномных вариантов

<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 35%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--varVCFfile</code></td>
<td><code>-</code></td>
<td><p><strong>путь к файлу</strong></p>
<p>Путь к файлу <a href="https://samtools.github.io/hts-specs/VCFv4.2.pdf">VCF</a> c данными по вариации генома. В 10й колонке должен содержать информацию о
генотипе в формате 0/1.</p></td>
</tr>
</tbody>
</table>

### Вводные файлы для профиля покрытия

<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 23%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--inputBAMfile</code></td>
<td><code>-</code></td>
<td><p><strong>путь к файлу</strong></p>
<p>Путь к файлу BAM-файлу для построения профилей покрытия генома в режиме <code>inputAlignmentsFromBam</code></p></td>
</tr>
</tbody>
</table>

### Параметры базы экзонных стыков (Splice Junctions)

<table>
<colgroup>
<col style="width: 30%" />
<col style="width: 23%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--sjdbFileChrStartEnd</code></td>
<td><code>-</code></td>
<td><p><strong>путь к файлу</strong></p>
<p>Путь к файлу с геномными координатами экзон-экзонных стыков. Может быть несколько файлов, перечисленных через пробел.</p></td>
</tr>
<tr class="even">
<td><code>--sjdbGTFfile</code></td>
<td><code>-</code></td>
<td><p><strong>путь к файлу</strong></p>
<p>Путь к GTF-файлу с аннотацией генома.</p></td>
</tr>
<tr class="odd">
<td><code>--sjdbGTFchrPrefix</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>префикс в начале имени хромосомы в GTF-файле. Как правило это <strong>“chr”</strong>. Может пригодиться при использовании аннотации ENSEMBL и референса UCSC.</p></td>
</tr>
<tr class="even">
<td><code>--sjdbGTFfeatureExon</code></td>
<td><code>exon</code></td>
<td><p><strong>строка</strong></p>
<p>Название атрибута в <a href="https://www.ensembl.org/info/website/upload/gff.html">GTF-файле</a>, который будет использоваться в качестве экзонов при построении транскриптов.</p></td>
</tr>
<tr class="odd">
<td><code>--sjdbGTFtagExonParentTranscript</code></td>
<td><code>transcript_id</code></td>
<td><p><strong>строка</strong></p>
<p>Название атрибута в GTF-файле, который будет использоваться качестве идентификатора <em>(ID)</em> порождающего транскрипта <em>(parent transcript).</em></p></td>
</tr>
<tr class="even">
<td><code>--sjdbGTFtagExonParentGene</code></td>
<td><code>gene_id</code></td>
<td><p><strong>строка</strong></p>
<p>Название атрибута в GTF-файле, который будет использоваться качестве идентификатора <em>(ID)</em> порождающего гена <em>(parent gene).</em></p></td>
</tr>
<tr class="odd">
<td><code>--sjdbGTFtagExonParentGeneName</code></td>
<td><code>gene_name</code></td>
<td><p><strong>строка</strong></p>
<p>Название атрибута в GTF-файле, который будет использоваться качестве названия <em>(name)</em> порождающего гена <em>(parent gene).</em></p></td>
</tr>
<tr class="even">
<td><code>--sjdbGTFtagExonParentGeneType</code></td>
<td><code>gene_type gene_biotype</code></td>
<td><p><strong>строка</strong></p>
<p>Название атрибутов в GTF-файле, который будет использоваться качестве типа (белок-кодирующий, некодирующий и пр.) порождающего гена <em>(parent gene type).</em></p></td>
</tr>
<tr class="odd">
<td><code>--sjdbOverhang</code></td>
<td><code>100</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>длина д онорской/акцепторной последовательности с каждой стороны экзон-экзонного стыка. В идеале должно быть на 1 короче длины рида.</p></td>
</tr>
<tr class="even">
<td><code>--sjdbScore</code></td>
<td><code>2</code></td>
<td><p><strong>целое число</strong></p>
<p>Дополнительный бонус за выравнивание <em>(extra alignment score)</em>, которое пересекает базу экзонных стыков.</p></td>
</tr>
<tr class="odd">
<td><code>--sjdbInsertSave</code></td>
<td><code>Basic</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает, какие файлы сохранять, когда информация об экзонных стыках добавляется на стадии выравнивания:</p>
<p><code>Basic</code> - только малые стыки/файлы с транскриптами;</p>
<p><code>All</code> - все файлы, включая дополнительные файлы индексов. По сути это создаст измененную копию геномного индекса в папке, из которой была запущена программа.</p></td>
</tr>
</tbody>
</table>

### Параметры прочтений

<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 18%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--readFilesType</code></td>
<td><code>Fastx</code></td>
<td><p><strong>строка</strong></p>
<p>Формат, в котором предоставлены риды:</p>
<p><code>Fastx</code> - либо FASTA, либо FASTQ;</p>
<p><code>SAM SE</code>- SAM или BAM выравнивания односторонних прочтений<sup><strong>1</strong></sup>;</p>
<p><code>SAM PE</code>- SAM или BAM выравнивания двусторонних прочтений<sup><strong>1</strong></sup>.</p>
<p><strong>1 -</strong> При работе с BAM файлами используйте параметр <code>--readFilesCommand samtools view</code></p></td>
</tr>
<tr class="even">
<td><code>--readFilesSAMattrKeep</code></td>
<td><code>All</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает, какие флаги в SAM-файле, предоставленном в качестве файла с прочтениями<br />
(<code>--readFilesType SAM PE/SE</code>), сохранить в BAM-файле с<br />
выравниваниями. Это аналог опции <code>--readFile sSAMtagsKeep RG PL</code>. Варианты:</p>
<p><code>All</code> - оставить все флаги;</p>
<p><code>None</code> - не оставлять флаги.</p></td>
</tr>
<tr class="odd">
<td><code>--readFilesIn</code></td>
<td><code>Read1 Read2</code></td>
<td><p><strong>пути к файлам</strong></p>
<p>Адреса файлов c прочтениями. Сначала первый рид (или список через запятую), потом спаренные риды через пробел (если есть).</p>
<p>Примеры:</p>
<p><code>--readFilesIn file1.fq.gz</code> (один файл с односторонним прочтением)</p>
<p><code>--readFilesIn file1.fq.gz,file 2.fq.gz,file3.fq.gz</code> (односторонние прочтения разделены на три файла)</p>
<p><code>--readFilesIn file1_R1.fq.gz file1_R2.fq.gz</code> (спаренные риды, по одному файлу каждого)</p>
<p><code>--readFilesIn file1_R1.fq.gz,file2_R1.fq file1_R2.fq.gz,file2_R2.fq</code> (спаренные риды, несколько файлов)</p>
<p>Если файлов с ридами много (указаны через запятые), то в файл выравнивания можно добавить специальный атрибут <code>ID:</code> в файл с выравниванием. Для этого нужно воспользоваться опцией <code>--outSAMattrRGline</code>, предоставив ей список названий для групп ридов
через пр обел-запятую-пробел:</p>
<p><code>--readFilesIn file1.fq.fz,file 2.fq.gz,file3.fq.gz</code></p>
<p><code>--outSAMattrRGline ID:sample1 , ID:sample2 , ID:sample3</code></p>
<p>В примере выравниваются три файла, риды из каждого будут помечены. Обратите внимание, префикс <code>ID:</code> указан перед названием группы, а записи для образцов разделены не запятой, а запятой с пробелами с двух сторон.</p></td>
</tr>
<tr class="even">
<td><code>--readFilesManifest</code></td>
<td><strong><code>-</code></strong></td>
<td><p><strong>путь к файлу</strong></p>
<p>Путь к файлу с таблицей, содержащей адреса файлов с прочтениями <em>(manifest file)</em>. Это дает возможность выравнивать несколько экспериментов в одном запуске.</p>
<p>Таблица состоит из трех столбцов, разделенных табуляцией:</p>
<p>file1_R1.fq (tab) file1_R2.fq (tab) строка_флагов1</p>
<p>file2_R1.fq (tab) file2_R2.fq (tab) строка_флагов2</p>
<p>Для случая с односторонними прочтениями вместо второго рида указывается <code>-</code>:</p>
<p>file1.fq (tab) - (tab) строка_флагов1</p>
<p>file2.fq (tab) - (tab) строка_флагов2</p>
<p>Строка флагов может начинаться с префикса <code>ID:</code>, в таком случае может здесь можно перечислить несколько флагов через табуляцию.</p>
<p>Если в строке флагов нет префикса <code>ID:</code>, то название группы может быть только одноодин, префикс <code>ID:</code> будет добавлен к нему автоматически.</p>
<p>Все флаги будут записаны дословно в строку заголовков <code>@RG</code> SAM-файла.</p></td>
</tr>
<tr class="odd">
<td><code>--readFilesCommand</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>Команда, которую STAR должен запустить в командной строке перед загрузкой файлов с прочтениями.</p>
<p>STAR не умеет работать со зжатыми файлами. Чтобы открыть их, ему необходимо написать команду, при помощи которой он сможет деархивировать файлы. Эта команда должна сгенерировать из входных файлов текст, который будет отправлен в <code>STDOUT</code>.</p>
<p>Для чтения файлов <code>.fastq.gz</code>, в этой опции нужно указать <code>--readFilesCommand zcat</code> <sup><strong>1</strong></sup> или <code>--readFilesCommand gunzip -c</code> <sup><strong>2</strong></sup>.</p>
<p>Для чтения файлов <code>.fastq.bz</code>, в этой опции нужно указать <code>--readFilesCommand bzcat</code> <sup><strong>1</strong></sup> или <code>--readFilesCommand bunzip2 -c</code> <sup><strong>2</strong></sup>.</p>
<p><strong>1 -</strong> команда <code>zcat</code> или <code>bzcat</code> считывает сжатый текстовый файл и выводит в <code>STDOUT</code>, то есть на экран терминала.</p>
<p><strong>2 -</strong> команды <code>bunzip2</code> или <code>gunzip</code> деархивируют сжатые файлы и выводит содержимое в <code>STDOUT</code> при наличии опции <code>-c</code>.</p></td>
</tr>
<tr class="even">
<td><code>--readFilesPrefix</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>Префикс, который нужно добавить к названиям файлов в команде <code>--readFilesIn</code>, чтобы получился полный путь к файлам.</p></td>
</tr>
<tr class="odd">
<td><code>--readMapNumber</code></td>
<td><code>-1</code></td>
<td><p><strong>целое число</strong></p>
<p>Число ридов с начала файла, которые нужно выравнить на геном. Позволяет делать проверочные запуски выравнивания. Значение <code>-1</code> заставляет выравнить все риды.</p></td>
</tr>
<tr class="even">
<td><code>--readMatesLengthsIn</code></td>
<td><code>NotEqual</code></td>
<td><p><strong>строка</strong></p>
<p>Стоит ли программе ожидать, что длина имен, последовательностей, строки качества в файлах со спаренными ридами одинакова. Варианты: <code>Equal</code> или <code>NotEqual</code>. Последний вариант самый безопасный.</p></td>
</tr>
<tr class="odd">
<td><code>--readNameSeparator</code></td>
<td><code>/</code></td>
<td><p><strong>строка</strong></p>
<p>Символ в названии ридов (в FASTQ-файлах это строка, начинающаяся с <code>@</code>, в FASTA - строка, начинающаяся с <code>&gt;</code>), по которому будут обрезаться названия ридов в итоговом файле с выравниваниями. Если в названии ридов есть пробел, то после него название
ридов всегда будут обрываться.</p></td>
</tr>
<tr class="even">
<td><code>--readQualityScoreBase</code></td>
<td><code>33</code></td>
<td><p><strong>неотрицательное целое число</strong></p>
<p>Базовое значение для кодировки <a href="https://en.wikipedia.org/wiki/Phred_quality_score">Phred -score</a>. Символ с этим номером в таблице ASCII будет восприниматься как Phred=0. Для запусков Illumina использовать 33. Для запусков Solexa - 64.</p></td>
</tr>
</tbody>
</table>

### Обрезака ридов

<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 22%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--clipAdapterType</code></td>
<td><code>Hamming</code></td>
<td><p><strong>строка</strong></p>
<p>Способ удаления адаптера:</p>
<p><code>Hamming</code> - обрезание адаптера на основе дистанции Хамминга. Число несовпадающих нуклеотдиов определяется параметром <code>--clip5pAdapterMMp</code>;</p>
<p><code>CellRanger4</code> - 5’- и 3’- будут удалены аналогично способу, описанному в программе <code>CellRanger4</code> из пакета <a href="https://github.com/Martinsos/opal">Opal</a>;</p>
<p><code>None</code> - обрезания не происходит. Все парамтры, необходимые для обрезания, игнорируются.</p></td>
</tr>
<tr class="even">
<td><code>--clip3pNbases</code></td>
<td><code>0</code></td>
<td><p><strong>целые числа</strong></p>
<p>Число оснований, которое будет удалено с 3’ конца каждой пары. Если задано одно число, то программа будет удалять заданное количетсво букв у обоих спаренных ридов.</p></td>
</tr>
<tr class="odd">
<td><code>--clip3pAdapterSeq</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>Удалит заданную последовательность адаптера с 3’ конца ридов. Если записана одна последовательность, то левый и правый риды будут обризаться одинаково.</p>
<p>Можно задать значение <code>polyA</code>, это будет эквивалентно поли-А-хвосту с длиной, равной длине рида.</p></td>
</tr>
<tr class="even">
<td><code>--clip3pAdapterMMp</code></td>
<td><code>0.1</code></td>
<td><p><strong>вечественное число</strong></p>
<p>максимальная доля несовпадающих букв на 3’-конце рида в сравнении с последовательностью адаптера. Если приведено два числа, то для левого и правого рида этот параметр будет отличаться.</p></td>
</tr>
<tr class="odd">
<td><code>--clip3pAfterAdapterNbases</code></td>
<td><code>0</code></td>
<td><p><strong>целое число</strong></p>
<p>Число оснований, которое будет удалено с 3’-конца ридов после удаления адаптеров. Можно указать два числа для разных спаренных ридов.</p></td>
</tr>
<tr class="even">
<td><code>--clip5pNbases</code></td>
<td><code>0</code></td>
<td><p><strong>целое число</strong></p>
<p>Число оснований, которое будет удалено с 5’ конца каждой пары. Если задано одно число, то программа будет удалять заданное количетсво букв у обоих спаренных ридов.</p></td>
</tr>
</tbody>
</table>

### Ограничения памяти

<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 23%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--limitGenomeGenerateRAM</code></td>
<td><code>31000000000</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Максимальный объем оперативной памяти (байт) для генерации генома</p></td>
</tr>
<tr class="even">
<td><code>--limitIObufferSize</code></td>
<td><code>30000000 50000000</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Максимальный объем буфера (байт) для ввода/вывода на поток</p></td>
</tr>
<tr class="odd">
<td><code>--limitOutSAMoneReadBytes</code></td>
<td><code>100000</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Максимальный размер одной записи в SAM-файле (байт) на рид. Рекомендуется значение:</p>
<p>&gt; (2*(LengthMate1+LengthMate2 +100) * outFilterMultimapNmax</p></td>
</tr>
<tr class="even">
<td><code>--limitOutSJoneRead</code></td>
<td><code>1000</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Максимальное число экзонных стыков на рид (учитывая все множественные выравнивания)</p></td>
</tr>
<tr class="odd">
<td><code>--limitOutSJcollapsed</code></td>
<td><code>1000000</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Максимальное число экзонных стыков после удаления дупликатов</p></td>
</tr>
<tr class="even">
<td><code>--limitBAMsortRAM</code></td>
<td><code>0</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Максимальное количество оперативной памяти для сортировки BAM. Если равно 0, то будет равно размеру индекса. Значение 0 может быть использовано только вместе с параметром <code>--genomeLoadNoSharedMemory</code>.</p></td>
</tr>
<tr class="odd">
<td><code>--limitSjdbInsertNsj</code></td>
<td><code>1000000</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Максимальное число экзонных стыков, которое можно вставить в том случае, если анализ экзон-экзонных стыков происходит на стадии выравнивания.</p></td>
</tr>
<tr class="even">
<td><code>--limitNreadsSoft</code></td>
<td><code>-1</code></td>
<td><p><strong>целое число</strong></p>
<p>Мягкое ограничение на число ридов. <code>-1</code> означает бесконечность.</p></td>
</tr>
</tbody>
</table>

### Общие настройки вывода

<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--outFileNamePrefix</code></td>
<td><code>./</code></td>
<td><p><strong>строка</strong></p>
<p>Префикс, который будет добавлен к названию файлов оутпута. Это может быть адрес папки, куда вы хотите сохранить все файлы.</p></td>
</tr>
<tr class="even">
<td><code>--outTmpDir</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>Fastxпуть к директории для временных файлов. Все содержимое будет удалено по покончании программы.</p></td>
</tr>
<tr class="odd">
<td><code>--outTmpKeep</code></td>
<td><code>None</code></td>
<td><p><strong>строка</strong></p>
<p>Сохранять временные файлы после завершения программы (выбрать <code>All</code>) или нет (выбрать <code>None</code>).</p></td>
</tr>
<tr class="even">
<td><code>--outStd</code></td>
<td><code>Log</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает, какой из файлов будет направлен в STDOUT (на экран терминала). Варианты - логи <code>Log</code>, SAM-файл <code>SAM</code>, несортированный
BAM-файл <code>BAM_Unsorted</code>, сортированный по координатам BAM файл <code>BAM_SortedByCoordinate</code>, выравненные на транкриптом фрагменты
<code>BAM Quant</code>.</p></td>
</tr>
<tr class="odd">
<td><code>--outReadsUnmapped</code></td>
<td><code>None</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает, сохранить ли невыравненные или частичновыравненные риды в отдельный файл. Есть вариант <code>None</code> и <code>Fastx</code>. В последнем
случае будет сохранен отдельный FASTA/FASTQ-файл с названием <code>Unmapped.out.mate1/2</code></p></td>
</tr>
<tr class="even">
<td><code>--outQSconversionAdd</code></td>
<td><code>0</code></td>
<td><p><strong>целое число</strong></p>
<p>Заставляет добавить число к Phred-score. Позволяет конвертировать Phred между кодировкой +33 и +64. Например, можно добавить к
значениям качества Illumina 31, чтобы получить кодировку Phred+64.</p></td>
</tr>
<tr class="odd">
<td><code>--outMultimapperOrder</code></td>
<td><code>Old_2.4</code></td>
<td><p><strong>строка</strong></p>
<p>Порядок перечисления ридов с множественными выравниваниями в результатах:</p>
<p><code>Old_2.4</code> - квази-рандомный, используемых в версии STAR до 2.5.0.</p>
<p><code>Fastx</code> - рандомный порядок перечисления. Все выравнивания одного рида перечисляются друг за другом.</p></td>
</tr>
</tbody>
</table>

### Настройки вывода SAM/BAM

<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 22%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--outSAMtype</code></td>
<td><code>SAM</code></td>
<td><p><strong>строка</strong></p>
<p>Тип вывода SAM/BAM. Параметр принимает одно или два слова.</p>
<p>Первое означает тип файла выравнивания: <code>BAM</code>, <code>SAM</code>, <code>None</code> (ничего не выведет).</p>
<p>Второе (опционально):</p>
<p><code>Unsorted</code> - как обычно, риды лежат как попало;</p>
<p><code>SortedByCoordinate</code> - файл сразу будет отсортирован по координатам. Для этого потребуется больше оперативной памяти, что можно проконтролировать при помощи параметра <code>--limitBAMsortRAM</code>.</p></td>
</tr>
<tr class="even">
<td><code>--outSAMmode</code></td>
<td><code>Full</code></td>
<td><p><strong>строка</strong></p>
<p>Метод вывода в SAM:</p>
<p><code>None</code> - ничего не выводить;</p>
<p><code>Full</code> - выводить все;</p>
<p><code>NoQS</code> - выводить все, кроме оценки качества.</p></td>
</tr>
<tr class="odd">
<td><code>--outSAMstrandField</code></td>
<td><code>None</code></td>
<td><p><strong>строка</strong></p>
<p>Заставляет программу записывать в SAM-файл информацию о цепочке ДНК специально, чтобы результат воспринимался программой Cufflinks. Это необходимо для совместимости между файлом выравнивания и некоторыми программами
анализа.</p>
<p><code>None</code> - не используется;</p>
<p><code>intronMotif</code> - цепь ДНК записывается внутри атрибута <code>XS</code> (смотреть подробности в разделе про <code>--outSAMattributes</code>). При этом риды с неканоничными интронами будут удалены. Этот пункт нужен для анализа в Cufflinks
экспериментов, приготовленных по протоколу <strong><em>strand-specific RNA-seq</em></strong>.</p></td>
</tr>
<tr class="even">
<td><code>--outSAMattributes</code></td>
<td><code>Standard</code></td>
<td><p><strong>строка</strong></p>
<p>Задает список атрибутов SAM-файла, которые нужно вывести. Эти параметры будут находиться в 12-м опциональном поле таблицы вырвавниваний в виде записей формата Тэг:Tип_ переменной:Значение. Например, <code>FI:i:1 TC:i:3</code>
(здесь i означает integer, целое число).</p>
<p>Пресеты:</p>
<p><code>None</code> - никаких атрибутов</p>
<p><code>Standard</code> - NH HI AS nM</p>
<p><code>All</code> - NH HI AS nM NM MD jM jI MC ch</p>
<p>Варианты атрибутов, описывающих <strong>вырванивание</strong>:</p>
<p><code>NH</code> - число локусов, на которые рид картируется (1 для ридов с одним выравниванием);</p>
<p><code>HI</code> - индекс множественного выравнивания. Начинается с числа, заданного параметром <code>- -outSAMattrIHstart</code>;</p>
<p><code>AS</code> - скор локального выравнивания. +1/-1 за совп адение/несовпадение, плюс пенальти за инделы и пропуски. Для PE режима скор равен сумме для двух спаренных ридов;</p>
<p><code>nM</code> - число замен. Для PE режима суммируется по обоим ридам;</p>
<p><code>NM</code> - дистанция от референса. Считается как число событий редактирования, нужное, чтобы из одной последовтельности получить вторую;</p>
<p><code>MD</code> - строка, в которой закодированы основания референса, в которых произошли замены или делеции;</p>
<p><code>jM</code> - интронный мотив для всех экзонных стыков. 0:неканоничный; 1:GT/AG, 2: CT/AC, 3: GC/AG, 4: CT/GC, 5: AT/AC, 6: GT/AT. Если использовалась база аннотированных сплайс-сайтов, то к каждому мотиву добавляется 20;</p>
<p><code>jI</code> - старт и конец интронов (системе отсчета +1);</p>
<p><code>XS</code> - цепь референса, на которую выравнился рид согласно <code>- -outSAMstrandField</code>;</p>
<p><code>MC</code> - <a href="htt%20%20ps://%%2020%20%20%20dri%20ve5%20.com/usearc%20%20%20%20h/manual/cigar.html">C I GAR</a> строка для спаренного рида;</p>
<p><code>ch</code> - помечает все сегменты всех химерных выравниваний для<br />
<code>--chimOutType WithinBAM</code>;</p>
<p><code>cN</code> - число оснований, которые были удалены с 5’ и 3’-концов.</p>
<p>Варианты атрибутов, доступные в режиме работы с <strong>мутантными вариантами</strong>:</p>
<p><code>vA</code> - аллельный вариант;</p>
<p><code>vG</code> - координата варианта, перекрытого ридом;</p>
<p><code>vW</code> - 1 - выравнивание прошло фильтрацию WASP, 2-7 - выранвивание не прошло фильтрацию WASP. Указывается только при включенной опции <code>--waspOutputMode SAMtag</code>.</p>
<p>Варианты атрибутов, доступные в режиме работы <strong>STARsolo</strong> (д емультиплексирование scRNA-seq выравниваний):</p>
<p><code>CR</code> <code>CY</code> <code>UR</code> <code>UY</code> - последовательности (R) и качество (Y) клеточных (С) баркодов и UMI (U);</p>
<p><code>GX</code> <code>GN</code> - gene ID и gene name для ридов, попадающих в уникальных ген;</p>
<p><code>gx</code> <code>gn</code> - gene ID и gene name для ридов, попадающих в уникальный ген или в несколько генов;</p>
<p><code>CB</code> <code>UB</code> - клеточные баркоды и UMI после коррекции ошибок. Требуется установка параметра <code>--outSAMtype BAM SortedByCoordinate</code>;</p>
<p><code>sM</code> - общая оценка баркода. Чем выше, тем лучше риды с таким баркодом выравниваются;</p>
<p><code>sS</code> - вся последовательность баркода;</p>
<p><code>sQ</code> - качество всего баркода.</p>
<p><strong>Кастомные</strong> атрибуты, отсутствуют в официальной спецификации SAM/BAM:</p>
<p><code>ha</code> - гаплотип (1/2), когда картирование происходит на диплоидный геном. Нужно поставить параметр <code>--genomeTransformType Diploid</code> ;</p>
<p><code>rB</code> - область генома, в которой происходит выравнивание (alignment block);</p>
<p><code>vR</code> - координата варианат внутри рида.</p></td>
</tr>
<tr class="odd">
<td><code>--outSAMattrIHstart</code></td>
<td><code>1</code></td>
<td><p><strong>целое неотрицательное число</strong></p>
<p>Начальное значение для атрибута IH. Значение 0 может быть обязательным для некоторых программ, таких как <strong>Cufflinks</strong> или <strong>StringTie</strong></p></td>
</tr>
<tr class="even">
<td><code>--outSAMunmapped</code></td>
<td><code>None</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает, как выводить некартированные риды. Параметр состоит из двух частей.</p>
<p>Первая часть:</p>
<p><code>None</code> - не выводить;</p>
<p><code>Within</code> - вывести в основной SAM-файл.</p>
<p>Вторая часть:</p>
<p><code>KeepPairs</code> - записать непрокартированные спаренные риды рядом с прокартированной парой (если не было сортировки). Этот пункт имеет значение только для ридов с множественными выравниваниям.</p></td>
</tr>
<tr class="odd">
<td><code>--outSAMorder</code></td>
<td><code>Paired</code></td>
<td><p><strong>строка</strong></p>
<p>Тип сортировка для ридов в выравнивании:</p>
<p><code>Paired</code> - каждый спаренный рид помещается рядом с парой</p>
<p><code>PairedKeepInputOrder</code> - спаренные риды лежат друг за дружкой, но порядок ридов совпадает с исходным в FASTQ или FASTA.</p></td>
</tr>
<tr class="even">
<td><code>--outSAMprimaryFlag</code></td>
<td><code>OneBestScore</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает, какое выравнивание считать первичным. Все остальные выравнивания получат флаг 0x100 (В флаге восьмой бит справа будет приравнен 0).</p>
<p><code>OneBestScore</code> - одно выравнивание с высшим скором будет считаться первичным;</p>
<p><code>AllBestScore</code> - все вырванивания с высшим скором будут считаться первичными.</p>
<p>FLAG - это двоичное 16-битовое число, каждая цифра в котором указывает на определенное свойство рида. Например, если первый бит (0x1 в 16-ричной нотации) равен единице, то рид считается спаренным (0 - наоборот).
Если второй бит (0x2 в 16-ричной нотации) равен 1, то рид выравнен правильно вместе со своей парой (0 - наоборот). Если записать два бита одним двоичным числом, то число 11<sub>2</sub> означает, что рид имеет пару, и оба
рида в паре правильно выравнены. А если мы видим число 01<sub>2</sub>, то рид имеет пару, но оба выранены неправильно (дискордантно, например). Любое число в двоичной системе можно выразить в десятеричной. Например, 11<sub>2</sub>
эквивалентно 4<sub>10</sub>. Расшифровку флагов можно посмотреть в <a href="https://broadinstitute.github.io/picard/explain-flags.html">онлайн-калькуляторе</a>, его более <a href="https://www.samformat.info/sam-format-flag">красивой версии</a>,
или <a href="https://www.youtube.com/watch?v=qm4NGV79t4o">видео туториале</a>.</p></td>
</tr>
<tr class="odd">
<td><code>--outSAMreadID</code></td>
<td><code>Standard</code></td>
<td><p><strong>строка</strong></p>
<p>Тип записи для идентификатора рида <em>(read ID):</em></p>
<p><code>Standard</code> - первое слово (до пробела) в заголовке FASTQ или FASTA. Суффиксы <code>/1</code> и <code>/2</code> будут удалены.</p>
<p><code>Number</code> - номер рида <em>(index)</em> в FASTQ или FASTA.</p>
<p>Read ID указан в первой колонке SAM-файла (поле QNAME).</p></td>
</tr>
<tr class="even">
<td><code>--outSAMmapqUnique</code></td>
<td><code>255</code></td>
<td><p><strong>целое число от 0 до 255</strong></p>
<p>Устанавливает качество выравнивания для у никально-картируемых ридов. Это число будет записано во второй колонке (поле MAPQ) внутри SAM-файла.</p></td>
</tr>
<tr class="odd">
<td><code>--outSAMflagOR</code></td>
<td><code>0</code></td>
<td><p><strong>целое число от 0 до 65535</strong></p>
<p>Изменяет флаги в SAM-файле при помощи операции OR. После того, как STAR сформирует выравнивания, раздел FLAG SAM-файла будет сложет с заданным числом. Может пригодится для фильтрации выравниваний на основе флагов.</p>
<p>Подробнее про флаги можно прочитать в разделе про<br />
<code>--outSAMprimaryFlag</code>.</p>
<p>Поскольку в двоичной форме с любой цифрой можно проводить логические операции, то флаги можно модифицировать. STAR позволяет конвертировать флаги в итоговом выравнивании с помощью операций AND и OR. Например, можно
модифицировать флаг 00 с помощью операции 01 AND 10. Получится 00. Или можно выполнить операцию 01 OR 10 - получится 11.</p></td>
</tr>
<tr class="even">
<td><code>--outSAMflagAND</code></td>
<td><code>65535</code></td>
<td><p><strong>целое число от 0 до 65535</strong></p>
<p>Изменяет флаги в SAM-файле при помощи операции AND. После того, как STAR сформирует выравнивания, раздел FLAG SAM-файла будет сложет с заданным числом. Может пригодится для фильтрации выравниваний на основе флагов.</p>
<p>Подробнее про флаги можно прочитать в разделе про<br />
<code>--outSAMprimaryFlag</code>.</p>
<p>Подробнее про операции над флагами можно прочитать в разделе про<br />
<code>--outSAMflagOR</code> .</p></td>
</tr>
<tr class="odd">
<td><code>--outSAMattrRGline</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>Задает строку атрибутов в выравниваниях SAM-файла. Должна начинаться с тега <code>ID:</code></p>
<p>Атрибуты для разных вводных файлов могут отличаться, для чего нужно будет написать несколько строк атрибутов через пр обел-запятую-пробел:</p>
<p><code>--outSAMattrRGline ID:xxx , ID:zzz "DS:z z" , ID:yyy DS:yyyy</code></p>
<p>Обратите внимание, что теги, чье содержимое содержит пробелы, нужно писать в кавычках.</p></td>
</tr>
<tr class="even">
<td><code>--outSAMheaderHD</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>Задает первую строку заголовка (несет @HD флаг) SAM</p></td>
</tr>
<tr class="odd">
<td><code>--outSAMheaderPG</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>Дополнительная строка в SAM-заголовке. Будет нести тег @PG (программное обеспечение).</p></td>
</tr>
<tr class="even">
<td><code>--outSAMheaderCommentFile</code></td>
<td><code>-</code></td>
<td><p><strong>путь к файлу</strong></p>
<p>название файла, куда буду записаны коммендарии из SAM заголовка (несет тег @CO)</p></td>
</tr>
<tr class="odd">
<td><code>--outSAMfilter</code></td>
<td><code>None</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает, нужно ли записывать выравнивания на референсные последовательности, добавленные с помощью <code>--genomeFastaFiles</code> на этапе картирования, в основной SAM/BAM файл.</p>
<p><code>KeepOnlyAddedReferences</code> - сохранить только те выравнивания, что попадают на добавочный референс.</p>
<p><code>KeepAllAddedReferences</code> - сохранить все выравнивания в одном файле.</p>
<p>По умолчанию стоит <code>None</code>, то есть выравнивания на дополнительный референс сохраняются в отдельном файле.</p></td>
</tr>
<tr class="even">
<td><code>--outSAMmultNmax</code></td>
<td><code>-1</code></td>
<td><p><strong>целое</strong></p>
<p>Максимальное число выравниваний, которое сообщается для ридов с множественными выравниваниями. По умолчанию стоит -1, то есть сообщаются все (влоть до <code>--outFilterMultimapNmax</code>).</p></td>
</tr>
<tr class="odd">
<td><code>--outSAMtlen</code></td>
<td><code>1</code></td>
<td><p><strong>целое</strong></p>
<p>метод вычисления поля TLEN <em>(template length, длина фрагмента)</em> в SAM/BAM файле.</p>
<p><code>1</code> - от самого крайнего основания первого рида до самого крайнего основания второго рида.</p>
<p><code>2</code> - по крайним основаниям безотносительно от рида. Это принципиально, если один из ридов лег внутри второго (такое часто бывает после обрезания 5’-конца ридов).</p></td>
</tr>
<tr class="even">
<td><code>--outBAMcompression</code></td>
<td><code>-1</code></td>
<td><p><strong>целое от -1 до 10</strong></p>
<p>Уровень сжатия BAM-файла. Чем больше, тем сильнее сжатие. -1 означает обычное сжатие (~6).</p></td>
</tr>
<tr class="odd">
<td><code>--outBAMsortingThreadN</code></td>
<td><code>0</code></td>
<td><p><strong>целое неотричательное число</strong></p>
<p>Число потоков для сортировки BAM-файла</p></td>
</tr>
<tr class="even">
<td><code>--outBAMsortingBinsN</code></td>
<td><code>50</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Число геномных фрагментов при сортировке по координатам</p></td>
</tr>
</tbody>
</table>

### Процессинг BAM-файлов

<table>
<colgroup>
<col style="width: 43%" />
<col style="width: 28%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--bamRemoveDuplicatesTpe</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>Устанавливать метки на ПЦР-дупликаты. В версии 2.7.10b опция работает только для сортированных BAM-файлов и
только для парных прочтений.</p>
<p><code>-</code> - не маркировать дупликаты и не удалять их;</p>
<p><code>UniqueIdentical</code> - маркировать все риды с множественным картированием и ПЦР-дупликаты с уникальным
выравниванием;</p>
<p><code>UniqueIdenticalNotMulti</code> - устанавливать метки только на уникально-картируемые ПЦР-дупликаты, не на риды с
множественным картированием.</p></td>
</tr>
<tr class="even">
<td><code>--bamRemoveDuplicatesMate2basesN</code></td>
<td><code>0</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Устанавливает число основани с 5’конца рида R2, которое можно использовать для слияния ридов (используется для
идентификации TSS в <a href="https://www.encodeproject.org/data-standards/rampage/">RAMPAGE</a>).</p></td>
</tr>
</tbody>
</table>

### Вывод профиля покрытия в формате Wiggle или BedGraph

<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--outWigType</code></td>
<td><code>None</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает тип файла покрытия:</p>
<p><code>None</code> (не выводить),</p>
<p><code>wiggle</code>, <code>wiggle read2</code>, <code>wiggle read1_5p</code>,</p>
<p><code>bedGraph</code>, <code>bedGraph read2</code>, <code>bedGraph read1_5p</code>.</p>
<p>Величину сигнала внутри бина <strong>генома</strong> можно считать по фрагменту, 5’ концу первого рида (read1_5p) и по второму риду (read2). Последние варианты полезны для <a href="https://www.encodeproject.org/data-standards/rampage/">CAGE или
RAMPAGE</a>.</p></td>
</tr>
<tr class="even">
<td><code>--outWigStrand</code></td>
<td><code>Stranded</code></td>
<td><p><strong>строка</strong></p>
<p><code>Stranded</code> - указывает цепочку ДНК в итоговом файле;</p>
<p><code>Unstranded</code> - цепочка ДНК не будет проигнорирована.</p></td>
</tr>
<tr class="odd">
<td><code>--outWigReferencesPrefix</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>префикс в названии хромосом, который нужно вставить в wig-файл. Как правило, это “chr”. Может понадобиться для отображения wig-файла в UCSC-браузере. Значение <code>-</code> затавляет включать названия
хромосом как в BAM-файле.</p></td>
</tr>
<tr class="even">
<td><code>--outWigNorm</code></td>
<td><code>RPM</code></td>
<td><p><strong>строка</strong></p>
<p>Метод нормализации числа прочтений на бин: <code>RPM</code> или <code>None</code></p></td>
</tr>
</tbody>
</table>

### Фильтрация выравниваний

<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--outFilterType</code></td>
<td><code>Normal</code></td>
<td><p><strong>строка</strong></p>
<p>Тип фильтрации выравненных прочтений.</p>
<p><code>Normal</code> - стандартная, используются только текущие выранивания.</p>
<p><code>BySJout</code> - оставить только те риды, которые перекрывают сплайс-сайты, прошедшие фильтрацию в файл <code>SJ.out.tab</code></p></td>
</tr>
<tr class="even">
<td><code>--outFilterMultimapScoreRange</code></td>
<td><code>1</code></td>
<td><p><strong>целое число</strong></p>
<p>Оценка выравнивания максимального скора для фильтрации множественных выравниваний.</p></td>
</tr>
<tr class="odd">
<td><code>--outFilterMultimapNmax</code></td>
<td><code>10</code></td>
<td><p><strong>строка</strong></p>
<p>Максимальное число локусов, на которое может выравниваться рид. Если локусов выравнивания больше, то ни одно из выравниваний не
сообщается, а рид будет помечен как “mapped to too many loci” в файле <code>Log.final.out</code>.</p></td>
</tr>
<tr class="even">
<td><code>--outFilterMismatchNmax</code></td>
<td><code>10</code></td>
<td><p><strong>вещественное число</strong></p>
<p>Метод нормализации числа прочтений на бин: <code>RPM</code> или <code>None</code></p></td>
</tr>
<tr class="odd">
<td><code>--outFilterMismatchNoverLmax</code></td>
<td><code>0.3</code></td>
<td><p><strong>вещественное число</strong></p>
<p>Выравнивание будет сообщаться только в том случае, если оотношение числа ошибочных оснований к точно совпавшим с референсом будет
меньше или равно заданному числу.</p></td>
</tr>
<tr class="even">
<td><code>--outFilterMismatchNoverReadLmax</code></td>
<td><code>1.0</code></td>
<td><p><strong>вещественное число</strong></p>
<p>Выравнивание будет сообщаться только в том случае, если оотношение числа ошибочных оснований к длине рида меньше или равно
заданному значению.</p></td>
</tr>
<tr class="odd">
<td><code>--outFilterScoreMin</code></td>
<td><code>0</code></td>
<td><p><strong>целое</strong></p>
<p>Выравнивание будет сообщаться только в случае, если оценка за вырвавнивание не ниже заданного числа.</p></td>
</tr>
<tr class="even">
<td><code>--outFilterScoreMinOverLread</code></td>
<td><code>0.66</code></td>
<td><p><strong>вещественное число</strong></p>
<p>Тот же параметр, что и<br />
<code>--outFilterScoreMin</code>, только нормализованный на длину рида (сумму длин спаренных ридов).</p></td>
</tr>
<tr class="odd">
<td><code>--outFilterMatchNmin</code></td>
<td><code>0</code></td>
<td><p><strong>целое</strong></p>
<p>Выравнивание будет сообщаться только в случае, если число совпавших с референсом основание превышает указанное.</p></td>
</tr>
<tr class="even">
<td><code>--outFilterMatchNminOverLread</code></td>
<td><code>0.66</code></td>
<td><p><strong>вещественное число</strong></p>
<p>Тот же параметр, что и<br />
<code>--outFilterMatchNmin</code>, только нормализованный на длину рида (сумму длин спаренных ридов).</p></td>
</tr>
<tr class="odd">
<td><code>--outFilterIntronMotifs</code></td>
<td><code>None</code></td>
<td><p><strong>строка</strong></p>
<p>Фильтрация сплайс-сайтов.</p>
<p><code>None</code> - без фильтрации.</p>
<p><code>RmoveNoncanonical</code> - удалить выравнивания, которые содержат неканонические соединения.</p>
<p><code>RemoveNoncanonicalUnannotated</code> - удалить выравнивания, которые содержат неаннотированные неканоничные сплайс-соединения только
если они отсутствуют в базе сплайс-сайтов.</p></td>
</tr>
<tr class="even">
<td><code>--outFilterIntronStrands</code></td>
<td><code>RemoveInconsistentStrands</code></td>
<td><p><strong>строка</strong></p>
<p>Фильрация сплайс-сайтов по направлению ДНК</p>
<p><code>RemoveInconsistentStrands</code> - удалить выравнивания, которые имеют сплайс-соединения с неправильной цепью ДНК</p>
<p><code>None</code> - без фильтрации.</p></td>
</tr>
</tbody>
</table>

### Вывод сплайс сайтов в `SJ.out.tab`

<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 35%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--outSJtype</code></td>
<td><code>Standard</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает, выводить ли идентифицированные экзонные стыки в <code>SJ.out.tab</code> (<code>Standard</code>) или не выводить (<code>None</code>).</p></td>
</tr>
</tbody>
</table>

### Фильтрация слайс-сайтов

<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 26%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--outSJfilterReads</code></td>
<td><code>All</code></td>
<td><p>Указывает, какие риды добавлять в список сплайс-соединени:</p>
<p><code>All</code> - все;</p>
<p><code>Unique</code> - только уникально картируемые.</p></td>
</tr>
<tr class="even">
<td><code>--outSJfilterOverhangMin</code></td>
<td><code>30 12 12 12</code></td>
<td><p><strong>четыре целых числа</strong></p>
<p>Минимальная длина оверхэнга в неаннотированных сплайс-соединениях (с обеих сторон). Каждое число определяет разные типы мотивов на стыке сплайс-соединений:</p>
<ol type="1">
<li><p>неканоничные мотивы,</p></li>
<li><p>GT/AG и CT/AC,</p></li>
<li><p>GC/AG и CT/GC,</p></li>
<li><p>AT/AC и GT/AT.</p></li>
</ol>
<p>Значение <code>-1</code> будет означать, что для данного мотива сплайс-сайты не будут сообщаться.</p></td>
</tr>
<tr class="odd">
<td><code>--outSJfilterCountUniqueMin</code></td>
<td><code>3 1 1 1</code></td>
<td><p><strong>четыре целых числа</strong></p>
<p>Минимальная число уникально картируемых ридов на неаннотированных сайт сплайсинга. Каждое число определяет разные типы мотивов на стыке сплайс-соединений:</p>
<ol type="1">
<li><p>неканоничные мотивы,</p></li>
<li><p>GT/AG и CT/AC,</p></li>
<li><p>GC/AG и CT/GC,</p></li>
<li><p>AT/AC и GT/AT.</p></li>
</ol>
<p>Значение <code>-1</code> будет означать, что для данного мотива сплайс-сайты не будут сообщаться.</p>
<p>Сайт сплайсинга будет считаться валидным, если один из параметров<br />
<code>--outSJfilterCountUniqueMin</code> или<br />
<code>--outSJfilterCountTotalMin</code> будет удовлетворен.</p></td>
</tr>
<tr class="even">
<td><code>--outSJfilterCountTotalMin</code></td>
<td><code>3 1 1 1</code></td>
<td><p><strong>четыре целых числа</strong></p>
<p>Аналогично <code>--outSJfilterCountUniqueMin</code>, только указывает минимальное число любых (уникальных или множе ственно-картируемых) прочтений требуется, чтобы сайт сплайсинга считался
валидным.</p></td>
</tr>
<tr class="odd">
<td><code>--outSJfilterDistToOtherSJmin</code></td>
<td><code>10 0 5 10</code></td>
<td><p><strong>четыре целых неотрицательных числа</strong></p>
<p>минимально допустипая дистанция до следующего донор/акцепторного сайта сплайсинга. Не применяется к аннотированным сайтам сплайсинга.</p></td>
</tr>
<tr class="even">
<td><code>--outSJfilterIntronMaxVsReadN</code></td>
<td><code>50000  100000 200000</code></td>
<td><p><strong>N целых неотрицательных чисел</strong></p>
<p>Максимальная длина интрона (длина промежутка между донорским и акцепторным сайтом), поддержанного 1,2,3… N выравненными ридами.</p>
<p>Чтобы сплайс-сайт, обрамляющий интрон длиной 50000bp считался валидным, нужен всего 1 выравненный на сплайс-соединение рид.</p>
<p>Чтобы сплайс-сайт, обрамляющий интрон длиной 100000bp считался валидным, нужно уже два рида. Для интрона 200000bp, число выравненных на сплайс-соединение ридов должно составлять 3
шт. и т.д.</p></td>
</tr>
</tbody>
</table>

### Оценка выравниваний

<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 26%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--scoreGap</code></td>
<td><code>0</code></td>
<td><p><strong>целое</strong></p>
<p>штраф (пенальти) за сплайс-сайт</p></td>
</tr>
<tr class="even">
<td><code>--scoreGapNoncan</code></td>
<td><code>-8</code></td>
<td><p><strong>целое</strong></p>
<p>штраф за неканоническое сплайс-соединение (добавляется к <code>--scoreGap</code>)</p></td>
</tr>
<tr class="odd">
<td><code>--scoreGapGCAG</code></td>
<td><code>-4</code></td>
<td><p><strong>целое</strong></p>
<p>пенальти за GC/AG и CT/GC сплайс-соединение (добавляется к <code>--scoreGap</code>)</p></td>
</tr>
<tr class="even">
<td><code>--scoreGapATAC</code></td>
<td><code>-8</code></td>
<td><p><strong>целое</strong></p>
<p>пенальти за AT/AC и GT/AT сплайс-соединение (добавляется к <code>--scoreGap</code>)</p></td>
</tr>
<tr class="odd">
<td><code>--scoreGenomicLengthLog2scale</code></td>
<td><code>-0.25</code></td>
<td><p><strong>вещественное число</strong></p>
<p>Дополнительный бонус, логарифмически нормированный на геномную длину выравнивания:</p>
<p><em>scoreGenomicLengthLog2scale</em>* log<sub>2</sub>(genomicLength)</p></td>
</tr>
<tr class="even">
<td><code>--scoreDelOpen</code></td>
<td><code>-2</code></td>
<td><p><strong>целое</strong></p>
<p>Штраф за открытие делеции.</p>
<p>Если в делеции (пропуск в риде относительно референса) три нуклеотида, то штраф за открытие дается за первый нуклеотид. За каждый дополнительный нуклеотид добавляется штраф за
продолжение делеции.</p></td>
</tr>
<tr class="odd">
<td><code>--scoreDelBase</code></td>
<td><code>-2</code></td>
<td><p><strong>целое</strong></p>
<p>Штраф за продолжение делеции. Добавляется за каждый нуклеотид в делеции кроме первого, суммируется с <code>--scoreDelOpen</code>.</p>
<p>Пояснение смотреть в разделе про<br />
<code>--scoreDelOpen</code>.</p></td>
</tr>
<tr class="even">
<td><code>--scoreInsOpen</code></td>
<td><code>-2</code></td>
<td><p><strong>целое</strong></p>
<p>Штрав за начало встройки.</p>
<p>Если во встройке (инсерция нуклеотидов в риде) три нуклеотида, то штраф за открытие дается за первый нуклеотид. За каждый дополнительный нуклеотид добавляется штраф за продолжение
встройки.</p></td>
</tr>
<tr class="odd">
<td><code>--scoreInsBase</code></td>
<td><code>-2</code></td>
<td><p><strong>целое</strong></p>
<p>Штраф за продолжение встройки. Добавляется за каждый нуклеотид в делеции кроме первого, суммируется с <code>--scoreInsOpen</code>.</p>
<p>Пояснение смотреть в разделе про<br />
<code>--scoreInsOpen</code>.</p></td>
</tr>
<tr class="even">
<td><code>--scoreStitchSJshift</code></td>
<td><code>1</code></td>
<td><p><strong>целое</strong></p>
<p>Максимальное снижение оценки за выравнивание в процессе поиска сплайс-сайтов на этапе сшивки.</p></td>
</tr>
</tbody>
</table>

### Параметры выравнивания и поиска затравочной подстроки

<table>
<colgroup>
<col style="width: 37%" />
<col style="width: 24%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--seedSearchStartLmax</code></td>
<td><code>50</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Определяет точку начала поиска внутри рида. Рид разделяется на фрагменты не короче заданного числа.</p></td>
</tr>
<tr class="even">
<td><code>--seedSearchStartLmaxOverLread</code></td>
<td><code>1.0</code></td>
<td><p><strong>вещественное неотрицательное число</strong></p>
<p>То же, что и <code>--seedSearchStartLmax</code>, только нормализованное на длину лина (суму длин спаренных ридов).</p></td>
</tr>
<tr class="odd">
<td><code>--seedSearchLmax</code></td>
<td><code>0</code></td>
<td><p><strong>целое неотрицательное число</strong></p>
<p>Определяет максимальную длину затравочной подстроки. Если 0, то ограничения нет.</p></td>
</tr>
<tr class="even">
<td><code>--seedMultimapNmax</code></td>
<td><code>10000</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Только куски ридов, которые картируются меньше указанного числа раз, участвуют в процедуре сшивания.</p></td>
</tr>
<tr class="odd">
<td><code>--seedPerReadNmax</code></td>
<td><code>1000</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Максимальное число затравок на рид.</p></td>
</tr>
<tr class="even">
<td><code>--seedPerWindowNmax</code></td>
<td><code>50</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Максимальное число затравок на окно.</p></td>
</tr>
<tr class="odd">
<td><code>--seedNoneLociPerWindow</code></td>
<td><code>10</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Максимальное число локусов с одним зерном на окно выравнивания.</p></td>
</tr>
<tr class="even">
<td><code>--seedSplitMin</code></td>
<td><code>12</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Минимальная длина затравочных подстрок, разделенных N-ками или отделенных от спаренного рида пропуском.</p></td>
</tr>
<tr class="odd">
<td><code>--seedMapMin</code></td>
<td><code>5</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Минимальная длина затравочных подстрок для начального выравнивания рида.</p></td>
</tr>
<tr class="even">
<td><code>--alignIntronMin</code></td>
<td><code>21</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Минимальный размер интрона: геномный пропуск будет считаться интроном, если его длина больше или равна <code>alignIntronMin</code>. В противном случае пропуск
считается делецией.</p></td>
</tr>
<tr class="odd">
<td><code>--alignIntronMax</code></td>
<td><code>0</code></td>
<td><p><strong>целое неотрицательное число</strong></p>
<p>Максимальный размер интрона. Если 0, то максимальная дистанция будет определяться по формуле (2ˆ<code>winBinNbits</code>)*<code>winAnchorDistNbins</code>.</p></td>
</tr>
<tr class="even">
<td><code>--alignMatesGapMax</code></td>
<td><code>0</code></td>
<td><p><strong>целое неотрицательное число</strong></p>
<p>Максимальная дистанция между двумя спаренными ридами. Если 0, максимальная дистанция будет определяться по формуле (
2ˆ<code>winBinNbi ts</code>)*<code>winAnchorDistNbins</code>.</p></td>
</tr>
<tr class="odd">
<td><code>--alignSJoverhangMin</code></td>
<td><code>5</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Минимальный оверхенг (размер блока) для сплайсированных выравниваний.</p></td>
</tr>
<tr class="even">
<td><code>--alignSJstitchMismatchNmax</code></td>
<td><code>0 -1 0 0</code></td>
<td><p><strong>четыре целых числа</strong></p>
<p>Максимальное число замен для сшивки сплайс-соединений. -1 - неограниченное число. Каждое число обозначает отдельный тип сплайс-сайтов:</p>
<ol type="1">
<li><p>неканоничные мотивы,</p></li>
<li><p>GT/AG и CT/AC,</p></li>
<li><p>GC/AG и CT/GC,</p></li>
<li><p>AT/AC и GT/AT.</p></li>
</ol></td>
</tr>
<tr class="odd">
<td><code>--alignSJDBoverhangMin</code></td>
<td><code>3</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Минимальный оверхэнг (размер блока) для выравниваний на аннотированные сплайс-соединения.</p></td>
</tr>
<tr class="even">
<td><code>--alignSplicedMateMapLmin</code></td>
<td><code>0</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Минимальная картируемая длина для сплайсированного спаренного рида.</p></td>
</tr>
<tr class="odd">
<td><code>--alignSplicedMateMapLminOverLmate</code></td>
<td><code>0.66</code></td>
<td><p><strong>вещественное положительное число</strong></p>
<p>То же, что и <code>--alignSplicedMateMapLmin</code>, но нормализовано на длину спаренного рида.</p></td>
</tr>
<tr class="even">
<td><code>--alignWindowsPerReadNmax</code></td>
<td><code>10000</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Максимальное число окон на рид.</p></td>
</tr>
<tr class="odd">
<td><code>--alignTranscriptsPerWindowNmax</code></td>
<td><code>100</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Максимальное число транскриптов в окне.</p></td>
</tr>
<tr class="even">
<td><code>--alignTranscriptsPerReadNmax</code></td>
<td><code>10000</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Указывает максимальное число разных выравниваний на рид, по достижении которого поиск новых позиций для выравнивания прекращается.</p></td>
</tr>
<tr class="odd">
<td><code>--alignEndsType</code></td>
<td><code>Local</code></td>
<td><p><strong>строка</strong></p>
<p>Метод выравнивания концевых нуклеотидов рида:</p>
<p><code>Local</code> - стандартный локальный режим с мягким обрезанием <em>(soft-сlipping);</em></p>
<p><code>EndToEnd</code> - принудительно выравнивать по всей длине, не обрезать;</p>
<p><code>Extend5pOfRead1</code> - полностью выравнивать только 5’-конец первого рида, а все остальные концы выравнивать в локальном режиме;</p>
<p><code>Extend5pOfReads12</code> - полностью выравнивать только 5’-концы обоих ридов. Все остальные концы выравнивать в локальном режиме.</p></td>
</tr>
<tr class="even">
<td><code>--alignEndsProtrude</code></td>
<td><code>0 ConcordantPair</code></td>
<td><p><strong>целое число и строка</strong></p>
<p>Допускает ситуацию, когда конец спаренного рида перекрывается с началом рида, но образует выступающий конец <em>(protrusion)</em>. В <strong>bowtie2</strong> такие
пары ридов называются ласточкиным хвостом <em>(dovetail)</em> Например, когда 5’ конец (+) рида оказывается правее, 3’-конца (-) рида. Это возможно когда
риды обрезаны с 5’-конца. Параметр принимает число и строку. Число - это максимальное количество выступающих оснований. Строка указывает элайнеру,
каким образом записывать пару ридов:</p>
<p><code>ConcordantPair</code> - неправильно перекрывающиеся пары будут считаться конкордантными;</p>
<p><code>DiscordantPair</code> - неправильно перекрывающиеся пары будут считаться дискордантными.</p></td>
</tr>
<tr class="odd">
<td><code>--alignSoftClipAtReferenceEnds</code></td>
<td><code>Yes</code></td>
<td><p><strong>строка</strong></p>
<p>Позволить ли мягкую обрезку прочтений, пересекающих конец референсной хромосомы.</p>
<p><code>Yes</code> - да.</p>
<p><code>No</code> - запретить. Удобно для совместимости с Cufflinks.</p></td>
</tr>
<tr class="even">
<td><code>--alignInsertionFlush</code></td>
<td><code>None</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает, каким образом переносить позиции вырожденных инсерций (например, когда два нуклеотида АА выравниваются на одну букву А в референсе).</p>
<p><code>None</code> - указывать так, как программа указала с самого начала (случайно)</p>
<p><code>Right</code> - вырожденные инсерции переносятся направо. Т.е. левый нуклеотид в вырожденной инсерции всегда будет выравнен на геном.</p></td>
</tr>
</tbody>
</table>

### Работа со спаренными ридами

<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--peOverlapNbasesMin</code></td>
<td><code>0</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Минимальное число перекрывающихся оснований, при котором спаренные риды будут соединены и перевыравнены. Значение &gt;0 заставит
программу соединять перекрывающиеся спаренные риды.</p></td>
</tr>
<tr class="even">
<td><code>--peOverlapMMp</code></td>
<td><code>0.01</code></td>
<td><p><strong>вещественное неотрицательное число до 1</strong></p>
<p>Максимальная доля ошибочных оснований в области перекрытия ридов.</p></td>
</tr>
</tbody>
</table>

### Параметры окон для поиска (windows), якорных локусов (anchors) и бинов (bins)

<table>
<colgroup>
<col style="width: 41%" />
<col style="width: 29%" />
<col style="width: 29%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--winAnchorMultimapNmax</code></td>
<td><code>50</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Максимальное число якорных локусов (координаты выравнивания затравочная подстроки, которая имеет минимальное
число муножественных выравниваний), на которые нужно проводить выравнивание.</p></td>
</tr>
<tr class="even">
<td><code>--winBinNbits</code></td>
<td><code>16</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>логарифм по основанию 2 от размера бинов для окон, в которых будет происходить кластеризация затравочных
выравниваний. Каждое окно будет занимать целое число бинов.</p></td>
</tr>
<tr class="odd">
<td><code>--winAnchorDistNbins</code></td>
<td><code>9</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Максимальное число бинов между двумя якорными локусами, между которыми возможно объединение якорей в одно окно.</p></td>
</tr>
<tr class="even">
<td><code>--winFlankNbins</code></td>
<td><code>4</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Логарифм по основанию 2 от размера левого или правого франкирующего района в каждом окне.</p></td>
</tr>
<tr class="odd">
<td><code>--winReadCoverageRelativeMin</code></td>
<td><code>0.5</code></td>
<td><p><strong>целое неотрицательное число</strong></p>
<p>Минимальное относительное покрытие последовательности рида затравочными подстроками в окне. Используется только
для алгоритма STARlong.</p></td>
</tr>
<tr class="even">
<td><code>--winReadCoverageBasesMin</code></td>
<td><code>0</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Минимальное число оснований, покрытое затравочной последотельностью в окне. Используется только для алгоритма
STARlong.</p></td>
</tr>
</tbody>
</table>

### Работа с химерными выравниваниями

<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 21%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--chimOutType</code></td>
<td><code>Junctions</code></td>
<td><p><strong>строка</strong></p>
<p>указывает, каким образом выводить информацию о химерных выравниваниях:</p>
<p><code>Junctions</code> - вывести файл <code>Chimeric.out.junction</code>;</p>
<p><code>SeparateSAMold</code> - выводить в отдельный SAM-файл <code>Chimaric.out.sam</code>;</p>
<p><code>WithinBAM</code> - вывести в основной BAM файл с выравниваниями;</p>
<p><code>WithinBAM HardClip</code> - принудительная обрезка (hard-clipping) в разделе CIGAR для дополнительных химерных выравниваний;</p>
<p><code>WithinBAM SoftClip</code> - мягкая обрезка (soft-clipping) в разделе CIGAR для дополнительных химерных выравниваний.</p></td>
</tr>
<tr class="even">
<td><code>--chimSegmentMin</code></td>
<td><code>0</code></td>
<td><p><strong>целое неотрицательное число</strong></p>
<p>Минимальная длина химерных сегментов, если 0, то химерные выравнивания не выводятся.</p></td>
</tr>
<tr class="odd">
<td><code>--chimScoreMin</code></td>
<td><code>0</code></td>
<td><p><strong>целое неотрицательное число</strong></p>
<p>Минимальная итоговая (после суммирования) оценка для химерных сегментов в выравнивании.</p></td>
</tr>
<tr class="even">
<td><code>--chimScoreDropMax</code></td>
<td><code>20</code></td>
<td><p><strong>целое неотрицательное число</strong></p>
<p>Максимальное падение (разница) оценки выравнивания химерных сегментов (сумма оценки за выравнивание для всех химерных сегментов) в сревении с оценкой за целый рид.</p></td>
</tr>
<tr class="odd">
<td><code>--chimScoreSeparation</code></td>
<td><code>10</code></td>
<td><p><strong>целое неотрицательное число</strong></p>
<p>Минимальная разница (separation) между лучшей оценкой химерного выравнивания и оценкой для другого выравнивания.</p></td>
</tr>
<tr class="even">
<td><code>--chimScoreJunctionNonGTAG</code></td>
<td><code>-1</code></td>
<td><p><strong>целое неотрицательное число</strong></p>
<p>Штраф (penalty) за не-GT/AG химерных стыков.</p></td>
</tr>
<tr class="odd">
<td><code>--chimJunctionOverhangMin</code></td>
<td><code>20</code></td>
<td><p><strong>целое неотрицательное число</strong></p>
<p>Минимальный оверхенг вокруг химерного стыка.</p></td>
</tr>
<tr class="even">
<td><code>--chimSegmentReadGapMax</code></td>
<td><code>0</code></td>
<td><p><strong>целое неотрицательное число</strong></p>
<p>Максимальная длина пропуска и последовательности рида между химерными сегментами.</p></td>
</tr>
<tr class="odd">
<td><code>--chimFilter</code></td>
<td><code>banGenomicN</code></td>
<td><p><strong>строка</strong></p>
<p>Разные фильтры для химерных выравниваний:</p>
<p><code>None</code> - нет фильтрации;</p>
<p><code>banGenomicN</code> - запретить N-ки вокруг последовательности генома, окружающей стыки в химерных ридах.</p></td>
</tr>
<tr class="even">
<td><code>--chimMainSegmentMultNmax</code></td>
<td><code>10</code></td>
<td><p><strong>целое неотрицательное число</strong></p>
<p>Максимальное число множественных вырваниваний для главного химерного сегмента. Если равно 1, то запрещает множественное выравнивание основного химерного сегмента.</p></td>
</tr>
<tr class="odd">
<td><code>--chimMultimapNmax</code></td>
<td><code>0</code></td>
<td><p><strong>целое неотрицательное число</strong></p>
<p>Максимальное число множественных химерных выравниваний. По умолчанию, разрешены только уникальные химерные выравнивания.</p></td>
</tr>
<tr class="even">
<td><code>--chimMultimapScoreRange</code></td>
<td><code>1</code></td>
<td><p><strong>целое неотрицательное число</strong></p>
<p>Устанавливает, на сколько оценка за химерное выравнивание может быть ниже максимального значения, чтобы вывести для данного рида множественные выравнивания. Работает только если задано значение <code>--chimMultimapNmax</code> больше 1.</p></td>
</tr>
<tr class="odd">
<td><code>--chimNonchimScoreDropMin</code></td>
<td><code>20</code></td>
<td><p><strong>целое неотрицательное число</strong></p>
<p>Устанавливает величину, определяющую, будет ли программа искать химерные выравнивания. Чем больше, тем реже это будет происходить.</p>
<p>Чтобы программа начала искать химерные выравнивания, разница между оценкой за самое лучшее нехимерное выравнивание и оценкой за выравнивание всего рида, должно быть выше заданного числа.</p></td>
</tr>
<tr class="even">
<td><code>--chimOutJunctionFormat</code></td>
<td><code>0</code></td>
<td><p><strong>0 или 1</strong></p>
<p>Указывает на форматирование файла <code>Chimeric.out.junction</code>:</p>
<p><code>0</code> - нет строки заголовка и строк комментариев</p>
<p><code>1</code> - строка комментариев на конце файла: командна в командной строке, общее число ридов, число ридов с уникальным выравниванием, число ридов с множественным выравниванием.</p></td>
</tr>
</tbody>
</table>

### Подсчет числа прочтений в атрибутах генома по аннотации

<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 23%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--quantMode</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>Тип подсчета прочтений в аннотированных районах генома:</p>
<p><code>-</code> не делать подсчет;</p>
<p><code>TranscriptomeSAM</code> - вывести прочтения, выравненные на аннотированные гены, в отдельный SAM/BAM-файл.</p>
<p><code>GeneCounts</code> - подсчитать число ридов для каждого гена. <code>TranscriptomeSAM GeneCounts</code> - сделает оба варианта.</p></td>
</tr>
<tr class="even">
<td><code>--quantTranscriptomeBAMcompression</code></td>
<td><code>1</code></td>
<td><p><strong>целое число от -2 до 10</strong></p>
<p>Уровень сжатия BAM-файла с выравниваниями на транскриптом:</p>
<p><code>-2</code> - не выводить BAM файл, <code>-1</code> - сжатие по умолчанию (~6), <code>0</code> - нет сжатия, <code>10</code> - максимальное сжатие.</p></td>
</tr>
<tr class="odd">
<td><code>--quantTranscriptomeBan</code></td>
<td><code>IndelSoftclipSingleend</code></td>
<td><p><strong>строка</strong></p>
<p><code>IndelSoftclipSingleend</code> - запрещает подсчитывать выравнивания с инделами, подвергшиеся магкой обрезке выравнивания, односторонние выравнивания - совместимо с RSEM;</p>
<p><code>Singleend</code> - запретить подсчет односторонних прочтений.</p></td>
</tr>
</tbody>
</table>

### Двухкратное картирование ридов для аннотации сайтов сплайсинга

<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 25%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--twopassMode</code></td>
<td><code>None</code></td>
<td><p><strong>строка</strong></p>
<p><code>None</code> - 1-кратное выравнивание.</p>
<p><code>Basic</code> - включает режим двухкратного выравнивания. На первом райнде выравнивания будут аннотированы сайты сплайсинга новые сайты сплайсинга. На втором раунде все эти сайты будут использованы для
более тщательного повторной аннотации сайтов сплайсинга, что позволяет увеличить чувствительность поиска.</p></td>
</tr>
<tr class="even">
<td><code>--twopass1readsN</code></td>
<td><code>-1</code></td>
<td><p><strong>целое число</strong></p>
<p>Число ридов, которое нужно выравнить на первом раунде двухкратного выравнивания. Значение <code>-1</code> заставляет программу использовать все риды. Для лучшего качества советуют ставить очень большое число
ридов, либо оставлять -1.</p></td>
</tr>
</tbody>
</table>

### Параметры WASP

<table>
<colgroup>
<col style="width: 30%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--waspOutputMode</code></td>
<td><code>None</code></td>
<td><p><strong>строка</strong></p>
<p>Устанавливает параметры вывода из <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4626402/">WASP-алгоритма</a>, который используется для
аллель-специфичного картирования ридов и поиска молекулярных локусов количественных признаков.</p>
<p><code>None</code> - не использовать WASP-фильтрацию.</p>
<p><code>SAMtag</code> - добавить WASP-теги к выравниваниям, которые прошли WASP-фильтрацию.</p></td>
</tr>
</tbody>
</table>

### Параметры STARsolo (для анализа cingle cell RNA-seq)

<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 14%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="header">
<th>Параметр</th>
<th>Значение по умолчанию</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--soloType</code></td>
<td><code>None</code></td>
<td><p><strong>строка</strong></p>
<p>Тип single-cell RNA-seq эксперимента.</p>
<p><code>CB_UMI_Simple</code> - UMI и клеточный баркод имеют фиксированную длину и находятся во 2м риде. Это типично для Drop-seq и 10xChromium.</p>
<p><code>CB_UMI_Complex</code> - множество клеточных баркодов разной длины, один UMI фиксированной длины и одна адаптерная последовательность фиксированной длины во 2м риде (inDrop и ddSeq).</p>
<p><code>CB_samTagOut</code> - выводить клеточный баркод в тэгах CR и CB SAM-файла. Не производить подсчет UMI. Эта опция работает с <code>--outSAMtype BAM Unsorted</code> или <code>SortedByCoordinate</code>. Файл с полседовательностью клеточным баркода добавляется при помощи опции</p>
<p><code>--readFilesIn cDNA_read1 СellBC_read</code> в случае односторонних прочтений,</p>
<p><code>--readFilesIn cDNA_read1 cDNA_read2 СellBC_read</code> в случае двусторонних прочтений.</p>
<p><code>SmartSeq</code> - каждая клетка приведена в отдельном FASTQ-файле (двусторонние или односторонние). Баркоды соответствуют группам ридов. UMI отсутствуют. Выравнивания дедуплицируются в соответствии с началом и концом (предварительно проводится мягкая обрезка ридов).</p></td>
</tr>
<tr class="even">
<td><code>--soloCBwhitelist</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>Файл с разрешенным списком (<em>whitelist)</em> баркодов.</p>
<p>Только для <code>--soloType CB_UMI_Complex</code> разрешено использовать несколько файлов с белыми списками.</p>
<p><code>None</code> - все баркоды разрешены.</p></td>
</tr>
<tr class="odd">
<td><code>--soloCBstart</code></td>
<td><code>1</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Поцизия внутри рида, с которой начинается клеточный баркод.</p></td>
</tr>
<tr class="even">
<td><code>--soloCBlen</code></td>
<td><code>16</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Длина клеточного баркода.</p></td>
</tr>
<tr class="odd">
<td><code>--soloUMIstart</code></td>
<td><code>17</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Поцизия внутри рида, с которой начинается клеточный UMI.</p></td>
</tr>
<tr class="even">
<td><code>--soloUMIlen</code></td>
<td><code>10</code></td>
<td><p><strong>целое положительное число</strong></p>
<p>Длина UMI.</p></td>
</tr>
<tr class="odd">
<td><code>--soloBarcodeReadLength</code></td>
<td><code>1</code></td>
<td><p><strong>целое неотрицательное число</strong></p>
<p>Длина баркодированного рида.</p>
<p><code>1</code> - длина рида равна сумме <code>soloCBlen</code>+<code>soloUMIlen</code></p>
<p><code>0</code> - не определена. Не проверять.</p></td>
</tr>
<tr class="even">
<td><code>--soloBarcodeMate</code></td>
<td><code>0</code></td>
<td><p><strong>целое число</strong></p>
<p>Указывает, в каком из спаренных ридов искать баркоды.</p>
<p><code>0</code> - баркод в отдельном файле. Это должен быть последний файл в списке, приведенном внутри параметра <code>--readFilesIn</code></p>
<p><code>1</code> - баркод в R1.</p>
<p><code>2</code> - баркод в R2.</p></td>
</tr>
<tr class="odd">
<td><code>--soloCBposition</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>Позиция клеточного баркода в риде с баркодом. <code>--soloType CB_UMI_Complex</code>, причем баркоды должны находиться во втором риде.</p>
<p>Формат строки: <code>startAnchor_startPosition_endAnchor_endPosition</code></p>
<p><code>startAnchor</code> и <code>endAnchor</code> означают якорное основание для якорного клеточного баркода: 0 - начало рида, 1- конец рида, 2 - начало адаптера, 3 - конец адаптера.</p>
<p><code>startPosition</code> и <code>endPosition</code> - это положение (в системе 0+) клеточного баркода по отношению к якорному баркоду.</p>
<p>Строки для разных баркодов разделяются пробелами. Например, для inDrop строка будет выглядить следующим образом:</p>
<p><code>--soloCBposition 0_0_2_-1 3_1_3_8</code></p></td>
</tr>
<tr class="even">
<td><code>--soloUMIposition</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>То же, что и <code>--soloCBposition</code>, только для UMI.</p></td>
</tr>
<tr class="odd">
<td><code>--soloAdapterSequence</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>Последовательность к якорного баркоду в адаптере. Только одна последовательность разрешена.</p></td>
</tr>
<tr class="even">
<td><code>--soloAdapterMismatchesNmax</code></td>
<td><code>1</code></td>
<td><p><strong>целое неотрицательное число</strong></p>
<p>Число разрешенных замен в последовательности адаптера.</p></td>
</tr>
<tr class="odd">
<td><code>--soloCBmatchWLtype</code></td>
<td><code>1MM_multi</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает, каким образом сопоставлять клеточный баркод с белым списком.</p>
<p><code>Exact</code> - только точные совпадения разрешены</p>
<p><code>1MM</code> - только одно совпадение с белым списком с 1 заменой разрешено. Разрешенные клеточные баркоды должны иметь как минимум один рид с точным совпадением.</p>
<p><code>1MM_multi</code> - множественные совпадения с белым списком разрешены при наличии 1 замены. Вычисление апостериорной вероятности используется для выбора одного из совпадений. Разрешенные клеточные баркоды должны иметь как минимум один рид с полным совпадением. Эта опция лучше всего соотносится с параметрами <a href="htt%20ps://%20su%20pport%20.10xgen%20o%20m%20%20%20ics%20.com/%20s%20ingle-ce%20ll%20-gen%20e%%2020-exp%20ressio%20n/%20sof%20twa%20re/%20pipelines/l%20%20%20%20atest/installation">CellRanger 2.2
.0</a>.</p>
<p><code>1MM_multi_pseudocounts</code> - то же, что и <code>1MM_multi</code>, но псевдокаунт 1 добавлен ко всем баркодам в белом списке.</p>
<p><code>1MM_multi_Nbase_pseudocounts</code> - то же, что <code>1MM_multi_pseudocounts</code>, но множественное совпадение разрешено для баркодов с Nками. Эта опция лучше всего соотносится с <a href="https://support.10xgenomics.com/single-cell-gene-expression/software/release-notes/3-0">CellRanger 3.0 .0</a>.</p>
<p><code>EditDist_2</code> - позволяет редактировать дистанцию на 3 каждого баркода. Может включать одну делецию и одну инсерцию. Работает только с<br />
<code>--soloType CB_UMI_Complex</code>. Совпадение с несколькими баркодами в списке не допускается. Эта опция аналогична <a href="https://www.parsebiosciences.com/technology">ParseBio S plit-s eq</a></p></td>
</tr>
<tr class="even">
<td><code>--soloInputSAMattrBarcodeSeq</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает на аттрибуты в SAM-файле, которые будут использоваться для пометки последовательности баркодов. Опция необходима в режиме STARSolo c параметром <code>--readsFileType SAM [SE/PE]</code>, когда риды берутся из SAM-файлов.</p>
<p>Например, для 10xСell Ranger или STARsolo BAM-файлов, используются</p>
<p><code>--soloInputSAMattrBarcodeSeq CR UR</code></p></td>
</tr>
<tr class="odd">
<td><code>--soloInpu tSAMattrBarcodeQual</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает на аттрибуты в SAM-файле, которые будут использоваться для пометки качества баркодов. Опция необходима в режиме STARSolo c параметром <code>--readsFileType SAM [SE/PE]</code>, когда риды берутся из SAM-файлов.</p>
<p>Например, для 10xСell Ranger или STARsolo BAM-файлов, используются</p>
<p><code>--soloInputSAMattrBarcodeSeq CY UY</code></p>
<p>По умолчанию параметр имеет значение <code>-</code>, так что высе баркоды получают качество <strong>‘H’</strong></p></td>
</tr>
<tr class="even">
<td><code>--soloStrand</code></td>
<td><code>Forward</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает, есть ли у библиотеке sсRNA-seq специфичность по отношению к цепочке ДНК <em>(read strandness)</em>.</p>
<p><code>Unstranded</code> - нет информации о цепи ДНК в геноме.</p>
<p><code>Forward</code> - направление ДНК в риде совпадает с направлением молекул РНК.</p>
<p><code>Reverse</code> - направление ДНК в риде противоположно направлению РНК.</p></td>
</tr>
<tr class="odd">
<td><code>--soloFeatures</code></td>
<td><code>Gene</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает, по каким атрибутам в геноме суммировать UMI. Разные UMI, несущие одинаковый клеточный баркод, будут суммироваться для каждого атрибута:</p>
<p><code>Gene</code> - суммирование будет происходит по экзонам гена;</p>
<p><code>SJ</code> - суммирование будет происходить по сайтам сплайсинга, отчет будет выводиться в <code>SJ.out.tab</code>;</p>
<p><code>GeneFull</code> - суммирование будет происходить по всему гену, включая интроны и экзоны (аля пре-мРНК).</p>
<p><code>GeneFull_ExonOverIntron</code> - суммироваться будут все риды, перекрывающиеся с геном в интронах и экзонах, но предпочтение отдается ридам, которые перекрываются с экзонами на 100%.</p>
<p><code>GeneFull_Ex50pAS</code> - суммироваться будут риды, перекрывающиеся с геном в интронах и экзонах, но приортитет будет отдаваться ридам, которые на &gt;50% перекрываются с экзонами. Риды, которые на 100% перекрываются с экзонами, но лежат в антисмысловом направлении, учитываться не будут.</p></td>
</tr>
<tr class="even">
<td><code>--soloMultiMappers</code></td>
<td><code>-1</code></td>
<td><p><strong>строка</strong></p>
<p>Метод подсчета ридов со множественными выравниваниями. Если 100 ридов выравнивается сразу на 3 гена, то данная опция подскажет, как распределить их между генами.</p>
<p><code>Unique</code> - считать только риды, которые выравниваются только на один ген.</p>
<p><code>Uniform</code> - равномерно распределить риды со множественными выравниваниями по всем генам. Если 300 ридов выравнилось на 3 гена, то каждый ген получит к имеющимуся числу UMI плюс 100.</p>
<p><code>Rescue</code> - распределить добавочное число UMI пропорционально сумме уникальных и равномерно распределенных выравниваний. Если 300 ридов выравнилось на 3 гена, они имеют число уникальных выравниваний 100, 200 и 300, то в сумме имеем 900 ридов, при этом в среднем на ген добавляется 100 ридов с множественным выравниванием. В таком случае первый ген получит 300*(100+100)/(900) ридов из 300. Второй получит 300*(200+100)/900 из 300, а третий получит 300*(300+100)/900.</p>
<p><code>PropUnique</code> - распределить UMI пропорционально числу уникально картированных ридов. Если таковых в гене нет, то распределить равномерно. Если на четыре гена выравнилось уникальных ридов 0, 0, 100 и 200, то 400 ридов со множественным выравниванием будут распределены следующим образом: по 100 на каждый с нелувым значением, 67 на ген со значением 100 и 133 на ген со значением 200.</p>
<p><code>EM</code>- UMI с множественными выравниваниями распределеются при помощи EM-алгоритма (максимального ожидания).</p></td>
</tr>
<tr class="odd">
<td><code>--soloUMIdedup</code></td>
<td><code>1MM_All</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает на алгоритм, при помощи которого будет производиться дедупликация ридов. При этом риды с одинаковым UMI будут считаться ПЦР-дупликатами и колапсироваться (будет сохранен только один из всех).</p>
<p><code>1MM_All</code> - все UMI, находящиеся на дистанции 1 замены колапсируются.</p>
<p><code>1MM_Directional_UMItools</code> - использовать метод “directional” из <a href="https://umi-tools.readthedocs.io/en/latest/index.html">UMI- tools</a>;</p>
<p><code>1MM Directional</code> - аналогично <code>1MM_Directional_UMItools</code>, но с более строгим критерием для дуплицированных UMI;</p>
<p><code>Exact</code> - только точно совпадающие UMI колапсируются.</p>
<p><code>NoDedup</code> - не проводить дедупликацию, считать все риды.</p>
<p><code>1MM_CR</code> - применить алгоритм <a href="https://support.10xgenomics.com/single-cell-gene-expression/software/release-notes/3-0">CellR anger2- 4</a> для дедупликации 1MM UMI.</p></td>
</tr>
<tr class="even">
<td><code>--soloUMIfiltering</code></td>
<td><code>-</code></td>
<td><p><strong>строка</strong></p>
<p>Метод фильтрации UMI (для ридов, которые картируются на один ген)</p>
<p><code>-</code> - базовая фильтрация. Применяется для ридов с уникальным выравниванием гены.</p>
<p><code>MultiGeneUMI</code> - базовая фильтрация плюс удаление UMI с низкой представленностью, которые картируются более чем на один ген.</p>
<p><code>MultiGeneUMI_All</code> - базовая фильтрация плюс удаление всех UMI, которые картируются на более чем один ген.</p>
<p><code>MultiGeneUMI_CR</code> - базовая фильтрация плюс удаление UMI с низкой представленностью, которые картируются более чем на один ген. Алгоритм приведен в соответсвтие с <a href="htt%20ps://su%20p%20p%20%20%20ort%20.10xg%20e%20nomics.c%20om%20/sin%20g%%2020le-c%20ell-ge%20ne%20-ex%20pre%20ssi%20on/software%20%20%20%20/release-notes/3-0">CellRanger &gt; 3.0.0</a>. Работает только с параметром <code>--s oloUMIdedup 1MM_CR</code>.</p></td>
</tr>
<tr class="odd">
<td><code>--soloOutFileNames</code></td>
<td><code>Solo.out/ features.tsv barcodes.tsv matrix.mtx</code></td>
<td><p><strong>путь к папки и имена для файлов</strong></p>
<p>названия для файлов вывода STARsolo.</p>
<p>Первое слово - префикс к названиям файлов. Это папка, в которую будут сохранены файлы.</p>
<p>Второе слово - имя файла с названиями генов.</p>
<p>Третье - имя файла для хранения последовательностей баркодов.</p>
<p>Последнее слово - имя файла для хранения матрицы с числом прочтений на ген.</p></td>
</tr>
<tr class="even">
<td><code>--soloCellFilter</code></td>
<td><code>CellRanger2.2 3000 0.99 10</code></td>
<td><p><strong>название алгоритма плюс числовые параметры</strong></p>
<p>Тип алгоритма фильтрации клеток и параметры.</p>
<p><code>None</code> - не фильтровать клетки.</p>
<p><code>TopCells &lt;N&gt;</code> - выводить только N клеток, которые имеют максимальную сумму прочтений по UMI.</p>
<p><code>CellRanger2.2 &lt;N M m&gt;</code> - использовать алгоритм фильтрации CellRanger 2.2. Параметр N соответствует <code>nExpectedCells</code>, M соответствует <code>maxPercentile</code>, m соответсвует <code>maxMinRatio</code> в CellRanger. Если параметры не указывать, то это аналогично записи <code>CellRanger2.2 3000 0.99 10</code>.</p>
<p><code>EmptyDrops_CR &lt;список из 10 параметров&gt;</code> - аналоги алгоритма<br />
<a href="https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1662-y">EmptyDrops</a> в CellRanger.<br />
Всего здесь принимается 10 параметров.</p>
<p><code>nExpectedCells</code> <code>maxPercentile</code> <code>maxMinRatio</code> <code>indMin</code> <code>indMax</code> <code>umiMin</code> <code>umiMinFracMedian</code> <code>candMaxN</code> <code>FDR</code> <code>simN</code></p>
<p>Подробное описание алгоритма смотреть <a href="https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1662-y">здесь</a>. Если список параметров не указывать, то это аналогично записи</p>
<p><code>EmptyDro ps_CR 3000 0.99 10 45000 90000 500 0.0 1 20000 0.01 10000</code>.</p></td>
</tr>
<tr class="odd">
<td><code>--soloOutFormatFeaturesGeneField3</code></td>
<td><code>"Gene Expression"</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает заголовок для третьего столбика в файле <code>features.tsv</code>, где будут храниться названия генов. Если поставить <code>-</code>, то 3-тий столбик будет отсутствовать.</p></td>
</tr>
<tr class="even">
<td><code>--soloCellReadStats</code></td>
<td><code>None</code></td>
<td><p><strong>строка</strong></p>
<p>Указывает, выводить ли статистику по ридам для каждого клеточного баркода: <code>None</code> - нет, <code>Standard</code> - выводить в STDOUT.</p></td>
</tr>
</tbody>
</table>

# Источники

[Официальная документация к STAR версии 2.7.10b](https://github.com/alexdobin/STAR/blob/master/doc/STARmanual.pdf)

[Репозиторий в GitHub](https://github.com/alexdobin/STAR)

Оригинальная публикация [Dobin 2013](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3530905/)
