<div id="для-чего-нужен-docker" class="section level3" number="0.0.1">
<h3><span class="header-section-number">0.0.1</span> Для чего нужен Docker?</h3>
<p>Зачастую наиболее распространенные биоинформатические алгоритмы доступны только пользователям одной операционной системы (тот же <code>bowtie2</code> отсутствует на Windows). Чтобы решить эту проблему, некоторые разработчики стали предоставлять приложения в форме контейнеров <em>(conteiners)</em> - полностью изолированных от операционной системы самодостаточных наборов программ, включающие полный каталог скриптов и все зависимости. Разработчики приложения упаковывают в контейнер все необходимые компоненты операционной системы, и проверяют зависимости на совместимость, благодаря чему приложение из контейнера будет работать без ошибок на любой операционной системе. Запуск приложения в контейнере означает, что программа никак не зависит от окружающих процессов и операционной системы, в которой запущен контейнер. Самым распространенным менеджером контейнеров является Docker. С его помощью на ОС Windows можно запускать такие программы как <code>bowtie2</code>, <code>hisat2</code>, <code>higlass</code> и любые другие программы, которые были написаны специально под Linux или любую другую ОС. Вообще, разработчики все чаще предоставляют свои программы именно в форме docker-контейнеров, поэтому всем заинтересованным в биоинофрматике необходимо иметь хотя бы минимальные навыки работы с Docker.</p>
<p>{{% expand "Пояснения" %}}</p>
{{% notice "note" %}}
Например, разработчики создают приложение в системе разработки (например, Ubuntu) — там все настроено, приложение работает. Когда приложение готово, его нужно перенести в систему тестирования, а затем в продуктивную среду (например, macOS или Windows). Если в одной из сред нет нужной зависимости, приложение не будет работать. Программистам придется отвлечься от разработки и совместно с командой поддержки разобраться в ситуации. В контейнерах такой проблемы нет, так как они содержат в себе все необходимое для запуска приложения. Специалисты занимаются разработкой, а не решением инфраструктурных проблем.
{{% /notice %}}
{{% notice "note" %}}
На машине может быть запущено одновременно несколько контейнеров, при этом каждый контейнер будет занимать только строго определенную часть процессорной мощности и памяти.
{{% /notice %}}
{{% notice "note" %}}
По сути, контейнер является директорией, внутри которой хранятся все нужные для программы файлы и внутри которой производятся все процессы. После запуска контейнера файлы из операционной системы можно перекидывать внутрь контейнера в реальном времени.
{{% /notice %}}
{{% notice "note" %}}
Контейнеризация позволяет избежать проблем совместимости между операционными системами. Для того, чтобы запустить приложение под Linux на операционной системе Windows раньше приходилось устанавливать виртуальную машину, выделять под нее сектор на диске, искать в интернете образ операционной системы. Это было долго и требовало очень много вычислительных ресурсов. Контейнеры содержат только необходимые компоненты операционной системы и все исходные файлы предоставляются разработчиком, а загрузка контейнера происходит одной командой.
{{% /notice %}}
<p>{{% /expand %}}</p>
</div>
<div id="как-контейнеры-попадают-на-компьютер" class="section level3" number="0.0.2">
<h3><span class="header-section-number">0.0.2</span> Как контейнеры попадают на компьютер?</h3>
<p>Для того, чтобы запустить контейнер, docker требуется скачать все необходимые файлы. Исходные файлы организованы в виде так называемых образов. <em>Образ (image)</em> является пакетом данных, который содержит нужное для запуска контейнера программное обеспечение.</p>
{{% notice "note" %}}
Образ - это неизменяемый файл, содержащий исходный код, библиотеки, зависимости, инструменты и другие файлы, необходимые для запуска приложения в контейнере. Из-за того, что образы предназначены только для чтения их иногда называют снимками *(snapshot)*. Образ используется как шаблон для построения контейнера. При создании контейнера поверх образа добавляет слой, доступный для записи, что позволяет менять его по своему усмотрению.
{{% /notice %}}
<p>Перед запуском контейнера <strong>Docker</strong> должен скачать его образ (или несколько образов). В зависимости от программы размер образа может сильно отличаться (от нескольких мегабайт до десятков гигабайт). Скаченный образ будет храниться в файловой системе компьютера и будет использоваться при каждом запуске контейнера. Если вы удалите контейнер, то образ останется в системе. Однако, если вы запустили контейнер и сделали в нем какие-то изменения (добавили новые файлы, например), то внутри образа никаких изменений не будет. Так что при новом запуске контейнера все изменения будут утеряны, программа будет работать “с нуля”.</p>
<p>Пользователь может создавать образы самостоятельно либо получать их из репозитория <a href="https://hub.docker.com/">Docker Hub</a>. Удобно то, что пользователю docker не обязательно скачивать образ перед запуском контейнера. Команда <code>docker run</code>, которая запускает контейнер, при каждом вызове будет искать нужный образ в системе, и если такой отсутствует, то скачает его из хаба самостоятельно.</p>
</div>
<div id="архитектура-платформы-docker" class="section level3" number="0.0.3">
<h3><span class="header-section-number">0.0.3</span> Архитектура платформы <strong>Docker</strong></h3>
<p><strong>Docker</strong> предаставляет собой набор инструментов, программ и процессов (платформу, <em>platform</em>), которые обслуживают инфраструктуру контейнеров и образов на рабочей машине, дают возможность переносить контейнеры между рабочими станциями, организуют хранение образов контейнеров и доступ к ним на удаленных реестрах (персональных и корпоративных). Знакомство с <strong>Docker</strong> практически невозможно без понимания ключевых терминов, связанных с экосистемой этой программы.</p>
<ul>
<li><strong>Docker Daemon</strong></li>
</ul>
<p>Основной движущей силой Docker является так называемый демон <strong>Docker Daemon</strong>. По определению <em>демон</em> (<em>daemon</em>) - это служебная программа, которая запускается UNIX-системой в фоновом режиме и напрямую не взаимодействует с пользователем (в Windows такие программы назваются <em>службами</em>). Функцией демона <strong>Docker</strong> ялвяется запуск, поддержка и хранение образов и контейнеров. По своей сути <strong>Docker Daemon</strong> является сервером, только при обращении к нему вы запускаете на компьютере не HTML-страницы или базу данных, а контейнеры. Запуск <strong>Docker Daemon</strong> производится при помощи программы <code>dockerd</code>.</p>
<ul>
<li><strong>Docker-клиент</strong></li>
</ul>
<p>Работа с контейнерами, включая их запуск, обращение к ним или останувку, происходит через Docker-клиент. По сути это набор программ и подпрограмм, которые позволяют пользователю обращаться к демону. Взаимодействие демона и клиента происходит при помощи REST API (интерфейс клиент-сервер). Существует два вид клиентов:</p>
<p>** <strong>Docker Client</strong> используется для работы с программами, размещенными внутри одного контейнера, и вызывается программой <code>docker</code>. Собственно, с этим клиентом и мы и будем знакомиться ниже.</p>
<p>** <strong>Docker Compose</strong> используется для работы с большими и сложными программами, для которых требуется запускать и обрабатывать множество контейнеров. Этот клиент вызывается программой <code>docker-compose</code>.</p>
<ul>
<li>Движок <strong>Docker Engine</strong></li>
</ul>
<p>Программы <code>Docker</code> и <code>Dockerd</code> образуют клиент-серверное приложение, а общее название технологии, с помощью которой это приложение работает с контенерами, называется движок <strong>Docker</strong> (<strong>Docker Engine</strong>).</p>
<ul>
<li>Интерфейс командной строки <strong>Docker CLI</strong></li>
</ul>
<p>Работа с <strong>Docker</strong> большую часть времени проходит в командной строке. Большинство инструкций, которые пользователь может дать движку <strong>Docker</strong> представляют собой текстовые команды. Такой стиль управления программами называется <code>Command Line Interface</code>. Набор текстовых инструкций, с помощью которых происходит управление <strong>Docker</strong> называют <em>Docker command line interface</em>, или <em>Docker CLI</em>.</p>
<ul>
<li>Реестр <strong>Docker registry</strong></li>
</ul>
<p>Реестр <strong>Docker registry</strong> - это сервис, который хранит образы <strong>Docker</strong>. Наиболее известным реестром является <strong>Docker Hub</strong> - это бесплатный сервис, который может использовать каждый пользователь, и Docker по умолчанию настроен на поиск образов в Docker Hub. Но можно также запустить свой собственный частный реестр.</p>
<ul>
<li>Репозитории <strong>Docker</strong></li>
</ul>
<p>Репозиторием <strong>Docker Repository</strong> называют коллекцию образов, обладающих одним названием, но представляющих собой разные версии одного и того же приложения. Например, в репозитории <a href="https://hub.docker.com/_/python?tab=tags">Python</a> хранятся разные образы программы Python, в каждом из которых лежат разные версии интерпретатора. Идентификатор, указывающий на версию образа называется Тэгом (ярлыком, <code>Tag</code>). Тэг указывают после названия образа через двоеточие как дополнительный указатель на версию. По умолчанию Docker скачивает образы, с тэгом <code>latest</code>. Таким образом, если образ называется <code>python</code>, то это то же самое что <code>python:latest</code>. В указанном выше репозитории есть также версии <code>python:3.8-bullseye</code>, <code>python:3.10-bullseye</code> и куча других. По сути, репозиторий <strong>Docker</strong> - это раздел внутри реестра.</p>
<ul>
<li>Приложение <strong>Docker Desktop</strong></li>
</ul>
<p><strong>Docker Desktop</strong> — это приложение с графическим интерфейсом для ОС Mac, Linux или Windows, которое позволяет создавать и совместно использовать контейнерные приложения и микросервисы <strong>Docker</strong>. Оно позволяет вам управлять своими контейнерами, приложениями и образами без необходимости использовать терминал. Однако интерфейс <strong>Docker Desktop</strong> очень минималистичен и врд ли избавит вас от работы в командной строке.</p>
<ul>
<li>Расширения <strong>Docker Extensions</strong></li>
</ul>
<p>Расширения <strong>Docker</strong> представляют собой инструменты, созданные сторонними разработчиками для увеличения фнукционала <strong>Docker Desktop</strong>.</p>
<ul>
<li><strong>Dockerfile</strong></li>
</ul>
<p>Существует несколько стратегий для созднания образов. Самая интуитивно понятная - это создать образ напрямую из контейнера. Например, если вы запустили контейнер и внесли в него изменения, добавив или удалив программы, копировав внутрь новые файлы, то из видоизмененного контейнера можно сделать образ. Однако это делает затруднительным распространение контейнеров между устройствами, а для экономии пространства на компьютере требуется загружать образ в реестр.</p>
<p>Вторая возможность - создать текстовый файл, который позволит <strong>Docker</strong> сконструировать контейнер по заданному внутри файлу сценарию. Такие текстовые файлы назвают “Dockerfile” (без расширения), они почти ничего не весят и могут свободно переноситься между устройствами.</p>
</div>
<div id="установка-docker-desktop" class="section level3" number="0.0.4">
<h3><span class="header-section-number">0.0.4</span> Установка <strong>Docker Desktop</strong></h3>
<p>Сторонние руководства по установке можно найти по ссылкам ниже:</p>
<p>{{% expand "Полезные ссылки" %}}</p>
<p><a href="https://docs.docker.com/desktop/install/windows-install/">Документация по установке и системные
требования</a></p>
<p><a href="https://www.youtube.com/watch?v=a5mxBTGfC5k">Видео пример установки с
Hyper-V</a></p>
<p><a href="https://tretyakov.net/post/ustanovit-docker-na-windows-10-wsl2/">Инструкция по
установке на Windows с
WSL2</a></p>
<p><a href="https://ip-calculator.ru/blog/ask/ustanovka-docker-na-windows-10-home/">Еще одна инструкция по установке на Windows с
WSL2</a></p>
<p>{{% /expand %}}
Установка <strong>Docker Desktop</strong> происходит в несколько этапов.</p>
<ol style="list-style-type: decimal">
<li>В <strong>BIOS</strong> включить виртуализацию. Для этого нужно перезагрузить компьютер, войти в <strong>BIOS</strong>, затем в одном из окон найти опцию, которая включает слова “Virtualization” (Intel Virtualization Technology, VT, Virtualization и пр.) и “Hyper-V”. Затем перевести опцию в режим Enabled.</li>
</ol>
<div class="figure">
<img src="/Programs/Docker.files/bios.png?width=20pc" alt="" />
<p class="caption">Куда смотреть в BIOS?</p>
</div>
<ol start="2" style="list-style-type: decimal">
<li>Скачать установщик <strong>Docker Desktop</strong> на сайте <a href="https://www.docker.com/">docker.com</a>. Во время установки следовать инструкциям.</li>
</ol>
<div class="figure">
<img src="/Programs/Docker.files/docker.png?width=20pc" alt="" />
<p class="caption">Официальный сайт</p>
</div>
<p>Если все работает, то после установки вы должны увидеть вот такое окно:</p>
<div class="figure">
<img src="/Programs/Docker.files/Normal.png?width=20pc" alt="" />
<p class="caption">Когда все нормально</p>
</div>
<p>Но программа может выдать ошибки из-за неполной установки зависимостей. В таком случае будут видны такие ошибки:</p>
<div class="figure">
<img src="/Programs/Docker.files/noWSL.png?width=20pc" alt="" />
<p class="caption">WSL2 is not installed</p>
</div>
<div class="figure">
<img src="/Programs/Docker.files/incomplete.png?width=20pc" alt="" />
<p class="caption">WSL2 installation is incomplete</p>
</div>
<p>Вообще в сообщении об ошибке уже написано, что делать, но если есть затруднения, то нужно сделать как указано ниже.</p>
<p>{{% expand "   Видео-помощь" %}}</p>
<p><a href="https://www.youtube.com/watch?v=SjdFip4t3kI">WSL2 installation is incomplete</a></p>
<p><a href="https://www.youtube.com/watch?v=vJ2fJm3CoyE">WSL2 is not installed</a></p>
<p>{{% /expand %}}</p>
<p>Решением будет установка подсистемы Linux для Windows, как это описано в
руководстве <a href="https://learn.microsoft.com/ru-ru/windows/wsl/install">здесь</a> и
<a href="https://learn.microsoft.com/ru-ru/windows/wsl/install-manual">здесь</a>.
На первый взгляд это кажется очень сложным, но на самом деле потребует
только несколько раз войти в <strong>PowerShell</strong> и <strong>MicrosoftStore</strong>.</p>
<p>{{% expand "Как открыть PowerShell" %}}</p>
{{% notice "note" %}}
Чтобы войти в **PowerShell** нужно нажать Пуск и в строке поиска ввести *«PowerShell»*. Появившийся ярлык нажать правой кнопкой и выбрать опцию *«Запустить от имени администратора»*
{{% /notice %}}
<div class="figure">
<img src="/Programs/Docker.files/powershell.jpg?width=20pc" alt="" />
<p class="caption">Поиск в меню Пуск</p>
</div>
<p>{{% /expand %}}</p>
<p>Далее нажать <em>Пуск</em> и в строке поиска ввести <em>«Дополнительные компоненты»</em>. В появившемся окне выбрать <em>«Другие компоненты Windows»</em>. Далее поставить галочки напротив <em>«Платформа виртуальной машины»</em> и <em>«Подсистема Linux для Windows»</em>.</p>
<p>{{% expand "Как найти Другие компоненты Windows" %}}</p>
<p><img src="/Programs/Docker.files/additional.png?width=20pc&amp;classes=inline" alt="Поиск в меню Пуск" />
<img src="/Programs/Docker.files/others.png?width=20pc&amp;classes=inline" alt="Дополнительные компоненты" />
<img src="/Programs/Docker.files/components.png?width=20pc&amp;classes=inline" alt="Другие компоненты Windows" /></p>
<p>{{% /expand %}}</p>
</div>
<div id="пример-работы-с-docker-и-docker-desktop" class="section level3" number="0.0.5">
<h3><span class="header-section-number">0.0.5</span> Пример работы с <strong>Docker</strong> и <strong>Docker Desktop</strong></h3>
<p>Для быстрого знакомства создатели docker разработали контейнер getting-started. Правильный запуск контейнера сделает возможным просмотр ознакомительной документации через HTML-страницы в браузере. По сути, после запуска этого контейнера, у вас появится ссылка на статический вебсайт, на который вы сможете зайти через браузер. Ниже показана последовательность действий, которая позволит запустить этот контейнер.</p>
<ol style="list-style-type: decimal">
<li>Зайти в <code>PowerShell</code> или <code>CommandLine</code></li>
</ol>
<p>{{% expand "Способ 1" %}}</p>
<p>Нажать комбинацию клавиш <code>Windows+R</code> и в появившемся окне ввести
<em>powershell</em> или <em>cmd</em>, соответственно.</p>
<p>{{% /expand %}}</p>
<p>{{% expand "Способ 2" %}}</p>
<p>Нажать клавишу Windows или кнопку Пуск на рабочем столе и в появившейся
строке поиска ввести <em>powershell</em> или <em>Командная строка</em>,
соответственно. Открыть приложение.</p>
<p>{{% /expand %}}</p>
<ol start="2" style="list-style-type: decimal">
<li>Cкачать образ контейнера с помощью <code>docker pull</code></li>
</ol>
<p>В появившемся окне консоли ввести команду:</p>
<pre><code>
&gt; docker pull docker/getting-started
</code></pre>
<p>Эту команда написана в документации образа <a href="https://hub.docker.com/r/docker/getting-started">docker/getting-started</a> в правой части экрана.</p>
<p>В результате в окне приложения <strong>Docker Desktop</strong> в разделе images появится информация о скачанном образе. В данном случае это <code>docker/getting-started</code>. Нужно обратить внимание, что название образа совпадает с названием, которое было введен в команде выше.</p>
<div class="figure">
<img src="/Programs/Docker.files/image.png?width=20pc" alt="" />
<p class="caption">Image</p>
</div>
<p>Скачав образ один раз, с него можно запустить несколько одинаковых контейнеров.</p>
{{% notice "note" %}}
Не обязательно заранее скачивать образ. Если вы запускаете контейнер впервые (см. пункт ниже), то Docker самостоятельно скачает нужный образ и сразу запустит контейнер.
{{% /notice %}}
<ol start="3" style="list-style-type: decimal">
<li>Запустить контейнер.</li>
</ol>
<p>Запустить контейнер можно через консоль (при помощи команды <code>docker run</code>) либо при помощи кнопки <em>Run</em> в раделе <code>Images</code>. Во время запуска нужно будет заставить <strong>Docker</strong> связать контейнер с IP-адресом. Это позволит контейнеру вывести результат работы программы в браузер.</p>
<p>{{% expand "Запуск через консоль" %}}
В консоли ввести:</p>
<pre><code>
&gt; docker run -d -p 80:80 docker/getting-started
</code></pre>
<p>Эта команда написана в документации образа <a href="https://hub.docker.com/r/docker/getting-started">docker/getting-started</a>.
Обычно нет нужды переписывать или модифицировать ее. В ответ docker запустит сам контейнер. Либо сначала скачает образ (если это не было сделано ранее) и сразу скачает контейнер.</p>
<p>{{% /expand %}}</p>
<p>{{% expand "Запуск через Docker Desktop" %}}</p>
<p>В <strong>Docker Desktop</strong> зайти в раздел <code>Images</code> и нажать на кнопку Run справа от названия образа.</p>
<div class="figure">
<img src="/Programs/Docker.files/imagerun.png?width=20pc" alt="" />
<p class="caption">ImageRun</p>
</div>
<p>В сплывающем окне <code>Optional parameters</code> нужно обазятельно вести число 80 ячейку <code>Ports</code>. Только после этого вы сможете обратиться к контейнеру через браузер.</p>
<p>{{% /expand %}}</p>
<p>В разделе <code>Container</code> появится название контейнера. В данном случае это
<code>condescending_bhaskara</code>. Само название может отличаться от названия
образа, поскольку мы его не задавали изначально.</p>
{{% notice "note" %}}
По умолчанию docker дает контейнерам названия из двух слов, разделенных нижним подчеркиванием. Первое слово - это случайное прилагательное, а второе слово - имя известного ученого.
{{% /notice %}}
<p>Кроме того, у контейнера есть <em>индентификатор</em>. В данном случае это “f5a36b69f508”. Это кодовое название контейнера, которое может быть использовано в служебных командах <strong>Docker</strong>.
Есть еще параметр <code>port</code>, к которому мы обратимся позже.</p>
<div class="figure">
<img src="/Programs/Docker.files/container.png?width=20pc" alt="" />
<p class="caption">Container</p>
</div>
<p>Запущеный таким образом контейнер содержит программу, к которой мы можем обратиться при помощи браузера. Самый простой способ сделать это - нажать на троеточие напротив названия контейнера и в сплывающем окне вырбрать <code>Open with browser</code>. Либо можно открыть на компьютере браузер и ввести в адресную строку <code>localhost:80</code> или, что то же самое,
<code>http://localhost:80</code>. Нужно понимать, что параметр <code>Open with browser</code> и ссылка в браузере заработают только при правильной настройке контейнера.</p>
<div class="figure">
<img src="/Programs/Docker.files/program.png?width=20pc" alt="" />
<p class="caption">Container</p>
</div>
<p>Обратите внимание, что после того, как вы введете нужный адрес в адресную строку браузера, адрес поменяется в соответствием с URL-адресами, запрограммированными внутри контейнера.</p>
</div>
<div id="как-на-docker-запускать-программы" class="section level3" number="0.0.6">
<h3><span class="header-section-number">0.0.6</span> Как на <strong>Docker</strong> запускать программы</h3>
<p>Как было показано, запуск контейнера производится при помощи команды <code>docker run</code>. Показанный пример показвал, каким образом при помощи нее запускаются серверные приложения. Однако в общем случае <strong>Docker</strong> позволяет путем минимальных модификаций, запускать в командной строке Windows любые программы, написанные под Linux (или под любую другую ОС).</p>
<p>Синтаксис команды <code>docker run</code> следующий:</p>
<pre><code>
&gt; docker run [Параметры] название_образа [название_программы] [аргументы...]
</code></pre>
{{% notice "note" %}}
Необходимо внимательно следить за порядком написания отдельных частей команды. Параметры команды `docker run` должны быть написаны перед названием образа. После образа можно писать название программы, результат которой вы хотите получить. После названия программы должны идти соответсвующие аргументы.
{{% /notice %}}
<p>Приведем элементарный пример. В операционной системе Linux команда <code>echo "Hello World!"</code> выводит на экран терминала строку “Hello World!”. C помощью <strong>Docker</strong> мы можем запустить эту команду, загрузив образ Ubuntu (Debian или любой другой ОС Linux), и запустив внутри соответсвующего контейнера упомянутую команду следующим образом:</p>
<pre><code>&gt; docker pull ubuntu

...Несколько служебных сообщений...

&gt; docker run ubuntu echo &quot;Hello World!&quot;

Hello World!
</code></pre>
{{% notice "note" %}}
Представленный пример по сути является бессмысленным, поскольку програма `echo` спокойно запустится на современных вариантах ОС Windows. Однако строго говоря, программы echo под Windows не существует, так как само слово "echo" является псевдонимом (*alias*) программы `Write-Output`).
{{% /notice %}}
<p>Данный пример только демонстрирует, что запуск программ под, написанных под Unix-системы, на компьютере с ОС Windows с помощью <strong>Docker</strong> по сути не отличается от работы в нативном терминале Linux, только добавлением приставки, состоящей из служебных команд <code>docker run</code>. По сути, запуск программы начинается с вызова контейнера, после чего в нем запускается программа. В разделе ниже процесс создания контейнеров будет описан более подробно.</p>
</div>
<div id="работа-с-контейнерами" class="section level3" number="0.0.7">
<h3><span class="header-section-number">0.0.7</span> Работа с контейнерами</h3>
<div id="как-дать-контейнеру-название" class="section level4" number="0.0.7.1">
<h4><span class="header-section-number">0.0.7.1</span> Как дать контейнеру название?</h4>
<p>Параметр <code>--name</code> позволит присвоить контейнеру нужное имя. Например, после команды</p>
<pre><code>
&gt; docker run --name StaticSite -d -p 80:80 docker/getting-started
</code></pre>
<p>название контейнера будет “StaticSite” и можно будет использовать это название при обращении к контейнеру другими командами docker.</p>
</div>
<div id="как-найти-все-запущеные-контейнеры-и-их-параметры" class="section level4" number="0.0.7.2">
<h4><span class="header-section-number">0.0.7.2</span> Как найти все запущеные контейнеры и их параметры?</h4>
<p>Команда</p>
<pre><code>
&gt; docker ps
</code></pre>
<p>предоставить таблицу со списком всех установленных контейнеров. Ту же самую информацию можно увидеть в разделе <strong>Containers</strong> программы <strong>Docker Desktop</strong>. Дополнительные подробности можно рассмотреть в разделе <strong>Inspect</strong>, куда можно попасть если нажать на название контейнера. Стоит отметить, что по умолчанию <code>docker ps</code> (а также <strong>Containers</strong>) отображает только запущенные контейнеры. Можно заставить показать Docker все контейнеры, написав <code>docker ps --all</code> или, что то же самое, <code>docker ps -a</code></p>
<pre><code>
&gt; docker ps
</code></pre>
</div>
<div id="настройка-доступа-к-контейнеру-через-браузер" class="section level4" number="0.0.7.3">
<h4><span class="header-section-number">0.0.7.3</span> Настройка доступа к контейнеру через браузер</h4>
<p>Зачастую <strong>Docker</strong> используется для запуска на комьютере сервера. Как было показано выше, после включения контейнера <code>docker/getting-started</code> на компьютере запускается статичный HTML-сервер, к которому можно обращаться всегда, пока запущен контейнер. Правильная настройка доступа к серверу может быть проблематичной, если не понимать, как это работает (что затруднительно, особенно если не иметь представления о компьютерных сетях).</p>
<p>При запуске контейнера был указан параметр <code>-p 80:80</code>. Этот параметр заставляет привязать контейнер к IP-адресу локальной машины. А значит, чтобы открыть сайт, нам нужно ввести адрес на локальной машине.</p>
<p>Чтобы узнать, по какому адресу располагается сервер, который мы сейчас запустили, нужно обратить внимание на параметр <code>port</code>, который можно подробно рассмотреть в разделе <strong>Inspect</strong>, куда можно попасть если нажать на название контейнера.</p>
<div class="figure">
<img src="/Programs/Docker.files/port.png?width=20pc" alt="" />
<p class="caption">Container</p>
</div>
<p>Как альтернатива, можно ввести в <strong>PowerShell</strong> или <strong>cmd</strong> команду</p>
<pre><code>&gt; docker ps
</code></pre>
<p>В таком случае в консоли появится следующая таблица:</p>
<table>
<colgroup>
<col width="10%" />
<col width="18%" />
<col width="20%" />
<col width="11%" />
<col width="10%" />
<col width="16%" />
<col width="11%" />
</colgroup>
<thead>
<tr class="header">
<th>CONTAINER ID</th>
<th>IMAGE</th>
<th>COMMAND</th>
<th>CREATED</th>
<th>STATUS</th>
<th>PORTS</th>
<th>NAMES</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>f5a36b69f508</td>
<td>docker/getting-started</td>
<td>“/docker-entrypoint….”</td>
<td>2 minutes ago</td>
<td>Up 5 seconds</td>
<td>0.0.0.0:80-&gt;80/tcp</td>
<td>condescending_bhaskara</td>
</tr>
</tbody>
</table>
<p>Легко заметить, что информация в этой таблице почти полностью отображена в разделе <strong>Inspect</strong>. Здесь мы снова видим название контейнера, название образа, время создания, а также адрес порта.</p>
<p>Если мы знаем название контейнера, мы можем быстро узнать порт при помощи команды PowerShell</p>
<pre><code>
&gt; docker port название_контейнера
</code></pre>
<p>Данные в ячейке <code>PORTS</code> позволяют понять, как можно обращаться к серверу через браузер. В данном случае для нашего контейнера port обозначен как <code>0.0.0.0:80 -&gt;80/tcp</code>. Строка 0.0.0.0 перед двоеточием - это IP-адрес, по которому браузер будет искать запущеную нами программу. В
компьютерных сетях этим адресом обозначают все возможные IP-адреса, закрепленные за локальной машиной <code>localhost</code>, то есть закрепленные за
компьютером, на котором запущен docker. Число 80 после двоеточия означает, что чтобы найти данные, принадлежащие именно запущеному на локальной машине контейнеру, браузер должен будет искать пакеты данных с индексом 80. Это так называемый <em>порт контейнера</em>.</p>
<p>Фрагмент <code>-&gt;80/tcp</code> говорит о том, что браузер будет общаться с программой по протоколу TCP/IP через <em>порт хоста</em> c номером 80. Выбор порта и протокола передачи данных зависит от структуры сети и типа сервера, который запрограммирован в контейнере. В данном случае указан порт хоста 80, поскольку сервер передает HTML-страницы. Почтовые сервера обычно связываются с портом 25 или 110 и общаются по протоколу SMTP. Но вообще, это важно только для программистов. Поэтому, чтобы ничего не ломать, я предлагаю писать в параметре <code>-p</code> только тот адрес и протокол, которые упоминаются в документации к контейнеру.</p>
<p>Почему после запуска программы появился именно такой IP-адрес? В команде <code>docker run</code> мы вводили параметр <code>-p 80:80</code>. Перед двойточием указан порт контейнера, после двоеточия указан tcp-порт локальной машины под номером 80, по которому осуществляется передача данных по протоколу TCP/IP. Если команда выглядит “-p 8989:80”, то порт контейнера равен 8989, страницу нужно искать по IP-адресу локальной машины <em>localhost</em>, а передача данных будет производиться по протоколу TCP/IP. В таком случае, чтобы вызвать программу из браузера, нужно ввести адрес <code>localhost:8989</code>.</p>
<p>В <a href="https://docs.docker.com/network/links/">документации docker</a> есть много других примеров, как можно привязать контейнер к IP-адресам. Например, в команде <code>-p 8989:80</code> мы не пишем конкретный IP-адрес, к которому будет привязан контейнер, поэтому docker по умолчанию использует адрес 0.0.0.0. Но так как это общее название для всех адресов на локальной машине, мы не знаем, к какому IP-адресу локальной машины все-таки будет привязан контейнер. Если docker принимает в качестве IP-адреса 0.0.0.0, то к контейнеру смогут подключиться пользователи на всех сетевых интерфейсах (как публичных, так и частных), что обычно считается небезопасным. Чтобы попасть на созданный нами сервер, мы должны вписать в адресной строке “localhost:8989”. В то же время, обращение <code>8989:80</code> является сокращенной формой, и полностью команда выглядит как <code>-p 0.0.0.0:8989:80/tcp</code>. Зная это, мы можем менять IP-адрес, порт контейнера, порт локальной машины, а также протокол передачи данных. Например, ввод <code>-p 127.0.0.1:8000:80/tcp</code> заставит docker привязать контейнер к адресу <code>http:/127.0.0.1:8000</code>.</p>
</div>
<div id="как-приостановить-и-запустить-снова-выполнение-контейнера" class="section level4" number="0.0.7.4">
<h4><span class="header-section-number">0.0.7.4</span> Как приостановить и запустить снова выполнение контейнера?</h4>
<p>Остановить запущеный контейнер можно из окна docker в разделе <code>Containers</code>, нажатием на значок <strong>Stop</strong> (серый квадратик) напротив названия контейнера. Либо нужно в <code>PowerShell</code> ввести команду:</p>
<pre><code>
&gt; docker stop название_контейнера
</code></pre>
<p>Обратите внимание, что здесь нужно вводить не название образа, а название контейнера.</p>
<p>При остановке контейнера все данные и временные файлы внутри контейнера будут сохранены до следующего запуска.</p>
<p>Чтобы заново запустить выполнение контейнера нужно нажать на значок <strong>Start</strong> (серый треугольник) напротив остановленного контейнера. Либо нужно в <code>PowerShell</code> ввести команду:</p>
<pre><code>
&gt; docker restart название_контейнера
</code></pre>
</div>
<div id="режимы-работы-с-контейнером" class="section level4" number="0.0.7.5">
<h4><span class="header-section-number">0.0.7.5</span> Режимы работы с контейнером</h4>
<p>При запуске контейнера при помощи <code>docker run</code> в терминале вы должны сначала решить, хотите ли вы запускать контейнер в фоновом режиме (<em>detached mode</em>) или на переднем плане (<em>foreground mode</em>).</p>
<ul>
<li>Фоновый режим</li>
</ul>
<p>В примере выше мы запускали статический вебсайт следующим образом:</p>
<pre><code>
&gt; docker run -d -p 80:80 docker/getting-started
</code></pre>
<p>А сразу после ввода команды терминал выводил идентификатор образа и приглашал ввести следующую команду:</p>
<pre><code>
&gt; docker run -d -p 80:80 docker/getting-started

0e1d96e727a0d5b855b559689a91ca6e0bcf7149ce2492fa4525935336133950

&gt;
</code></pre>
<p>Даже после закрытия терминала контейнер продолжает работать, и статический вебсайт остается доступен до тех пор, пока контейнер не будет остановлен. Это так называемый режим <em>Detach</em>, или фоновый режим.</p>
<p>В режиме <em>Detach</em>, после ввода команды <code>docker run ...</code> в терминале, Docker запустит программу внутри контейнера в фоновом режиме и вы сможете вводить другие команды оболочки Windows в терминал. В таком случае можно будет спокойно закрыть терминал, а контейнер продолжит работу. Контейнеры, запущенные в фоновом режиме, останавливаются, когда завершается корневой процесс, используемый для запуска контейнера.</p>
<p>Запустить фоновый режим можно с помощью параметра <code>-d</code> или <code>--detach</code>, или <code>-d=true</code> (это одно и то же). В примере выше мы именно его и вводили. Если вы укажете вместе с параметром <code>-d</code> еще параметр <code>--rm</code>, то после выхода из контейнера или закрытия Docker контейнер будет полностью удален.</p>
<ul>
<li>Передний план</li>
</ul>
<p>В примере выше мы запускали контейнер <code>docker/getting-started</code> с параметром <code>-d</code> в фоновом режиме, что делало возможным пользоваться терминалом после открытия контейнера. Если убрать этот параметр, то в окно консоли начнут выводиться журнал сообщений (<em>logs, логи</em>) контейнера.</p>
<pre><code>&gt; docker run -p 80:80 docker/getting-started

/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration
...[много всего остального]...
2022/10/13 12:08:41 [notice] 1#1: start worker process 39
</code></pre>
<p>Теперь, требуется открыть новое окно терминала, чтобы вводить команды в консоль, так как терминал привязан к процессу, запущенному <strong>Docker</strong>’ом. Это и есть запуск на переднем плане. Если закрыть терминал, то контейнер будет остановлен. Если в данном случае добавить параметр <code>--rm</code>, то после завершения программы или после закрытия терминала контейнер будет удален.</p>
{{% notice "note" %}}
Те же логи можно просматривать и в **Docker Desktop** во вкладке *Logs* раздела Containers. Эту вкладку можно найти, если нажать на название контейнера. Логи несут служебную информацию и вряд ли пригодятся рядовому пользователю Docker.
{{% /notice %}}
<p>Логи представляют собой текстовые сообщения, которые выводятся программами внутри контейнера. Есть стандатные сообщения (например, о том, что программа запущена или выполнена) и сообщения об ошибках (например, ошибка из-за неверного формата файлов). Вывод стандартных сообщений и ошибок в окно консоли производится через разные потоки вывода, а именно поток стандартного вывода (<em>STDOUT</em>) и поток стандартных ошибок (<em>STDERR</em>), соответственно. На самом деле, сообщения, которые выводятся через поток ошибок не обязательно содержат ошибки, и два потока вывода нужны для только для удобства. По умолчанию режим переднего плана подразумевает, что в консольвыводятся сообщения из обоих потоков вывода.В зависимости от цели, которую вы преследуете, вы можете заставить <strong>Docker</strong> выводить только сообщения об ошибках или только стандартные сообщения, а также получать сообщения из стандартного ввода. Для этого требуется использовать параметр <code>-a</code>:</p>
<pre><code>
&gt; docker run ... -a stdout -a stderr ...
</code></pre>
<p>Вы можете вписать один или несколько потоков, повторив параметр <code>-a</code> несколько раз.</p>
<p>Легко обнаружить, что при запуске <code>docker/getting-started</code> c выводом сообщений по <code>STDOUT</code>, выводятся только сообщения о запуске скриптов:</p>
<pre><code>
&gt; docker run -a stdout -p 80:80 docker/getting-started

/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration
</code></pre>
<p>А при выводе только из <code>STDERR</code>, только сообщения о запуске процессов:</p>
<pre><code>
&gt; docker run -a stderr -p 80:80 docker/getting-started

2022/10/13 12:08:41 [notice] 1#1: start worker process 32
...[аналогичные сообщения]...
</code></pre>
<p>Эти сообщения посылаются программами, запущенными внутри контейнера. В зависимости от того, что за программа работает внутри контейнера, вы увидите разные сообщения.</p>
</div>
<div id="передача-данных-в-контейнер-через-поток-стандартного-ввода" class="section level4" number="0.0.7.6">
<h4><span class="header-section-number">0.0.7.6</span> Передача данных в контейнер через поток стандартного ввода</h4>
<p>Для работы некоторых приложения может потребоваться подать на вход текст, полученный из другой программы (через поток стандартного ввода <em>STDIN</em>) при помощи символа <code>|</code> (<em>pipe</em>). Чтобы сделать возможным получение данных из <em>STDIN</em>, необходимо упомянуть поток стандартного ввода в параметре <code>-a stdin</code>. В большинстве случаев, чтобы передать в контейнер данные из стандартного ввода придется также ввести параметр <code>-i</code>, который заставляет держать канал <em>STDIN</em> открытым, даже если контейнер не подключен к вводу (это задается создателем образа).</p>
<p>Продемонстрировать это можно, например, запуская программу cat, которая в Linux является стандартным средством просмотра текста через консоль, но в Windows эта программа отсутствует. Если ввести в консоль <strong>PowerShell</strong> команду</p>
<pre><code>
&gt; echo &quot;Hello World!&quot; | docker run --rm -i -a stdin -a stdout ubuntu cat
</code></pre>
<p>то Docker передаст тестовую строку “Hello World!” программе <code>cat</code>, запущеной в контейнере из образа <code>ubuntu</code> (содержит минимальный набор компонентов ОС Linux), через <em>STDIN</em>. В свою очередь, cat передаст полученный текст в окно консоли через <em>STDOUT</em>.</p>
<p>В терминале мы увидим сообщение</p>
<pre><code>
Hello World!

&gt; 
</code></pre>
<p>Когда программа cat завершит выполнение, то контейнер будет удален благодаря параметру <code>--rm</code>.</p>
</div>
<div id="запуск-контейнера-в-интерактивном-режиме" class="section level4" number="0.0.7.7">
<h4><span class="header-section-number">0.0.7.7</span> Запуск контейнера в интерактивном режиме</h4>
<p>Контейнер может содержать компоненты ядра операционной системы, а значит, в ряде случаев внутри контейнера можно будет запускать собственный терминал. Это напоминает работу в виртуальной машине. Чтобы запустить терминал, нужно запустить <code>docker run</code> с параметром <code>-t</code> и <code>-i</code> одновременно (часто пишут одним словом <code>-ti</code> или <code>-it</code>). Для примера, следующая команда открывает в PowerShell терминал Ubuntu:</p>
<pre><code>
&gt; docker run --rm -it ubuntu
</code></pre>
<p>В появившемся терминале можно вводить команды bash. Ниже я проверяю версию Ubuntu, обратившись к стандартному файлу os-ubuntu:</p>
<pre><code>&gt; docker run --rm -it ubuntu

root@df7701d1e063:/# cat /etc/os-release
PRETTY_NAME=&quot;Ubuntu 22.04.1 LTS&quot;
NAME=&quot;Ubuntu&quot;
VERSION_ID=&quot;22.04&quot;
VERSION=&quot;22.04.1 LTS (Jammy Jellyfish)&quot;
VERSION_CODENAME=jammy
ID=ubuntu
ID_LIKE=debian
HOME_URL=&quot;https://www.ubuntu.com/&quot;
SUPPORT_URL=&quot;https://help.ubuntu.com/&quot;
BUG_REPORT_URL=&quot;https://bugs.launchpad.net/ubuntu/&quot;
PRIVACY_POLICY_URL=&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;
UBUNTU_CODENAME=jammy
root@df7701d1e063:/#
</code></pre>
<p>По сути, <code>docker run --rm -it ubuntu</code> запустила образ операционной системы <code>Ubuntu</code> в терминале Windows. По идее, это полнофункциональная ОС. Все равно, что запустить виртуальную машину с OC Linux, войти на сервер через или войти в терминал на компьютере с этой ОС.</p>
{{% notice "warning" %}}
Запрещено вводить параметр -t, если контейнер получает данные через конвейер pipe (знак |).
{{% /notice %}}
</div>
<div id="запуск-команд-внутри-конвейера-запущенного-в-фоновом-режиме" class="section level4" number="0.0.7.8">
<h4><span class="header-section-number">0.0.7.8</span> Запуск команд внутри конвейера, запущенного в фоновом режиме</h4>
<p>Если внутри конвейера есть компоненты ядра операционной системы, то можно запустить их при помощи терминала внутри ковейера. Запустить терминал можно из <strong>Docker Desktop</strong>, если в разделе <em>Containers</em>. Для этого нужно либо нажать на троеточие напротив названия терминала и выбрать <em>Open in terminal</em>, либо нажать на имя контейнера и открыть вкладку <em>CLI</em> (правый верхний угол экрана).</p>
<p>Если в запущеном контейнере есть программы, которые вы хотите запустить, то нужно воспользоваться командой</p>
<pre><code>
&gt; docker exec название_контейнера название_программы [аргументы]
</code></pre>
<p>Например, после запуска контейнера <code>ubuntu</code> можно запустить команду <code>cat /etc/os-release</code>, которая в Linux покажет версию операционной системы (то же самое, что показано в примере с запуском контейнера в интерактивном режиме:</p>
<pre><code>
&gt; docker run -d -i --name Ubuntu_container ubuntu

3586325f911cd4a83600b08aff7e8e00d1c2ccf5bef5ce77b22a52fe38ccde1d

&gt; docker exec Ubuntu_container cat /etc/os-release

PRETTY_NAME=&quot;Ubuntu 22.04.1 LTS&quot;
NAME=&quot;Ubuntu&quot;
VERSION_ID=&quot;22.04&quot;
VERSION=&quot;22.04.1 LTS (Jammy Jellyfish)&quot;
VERSION_CODENAME=jammy
ID=ubuntu
ID_LIKE=debian
HOME_URL=&quot;https://www.ubuntu.com/&quot;
SUPPORT_URL=&quot;https://help.ubuntu.com/&quot;
BUG_REPORT_URL=&quot;https://bugs.launchpad.net/ubuntu/&quot;
PRIVACY_POLICY_URL=&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;
UBUNTU_CODENAME=jammy
</code></pre>
<p>Первая команда запускает контейнер в фоновом режиме, при этом команда <code>-i</code> не позволит контейнеру остановиться, поскольку он будет ожитать ввода из <em>STDIN</em>.</p>
<p>Вторая команда запускает в контейнере нужную команду cat, которая выводит результат в <em>STDOUT</em>, то есть прямо в терминал.</p>
</div>
<div id="как-удалить-контейнер" class="section level4" number="0.0.7.9">
<h4><span class="header-section-number">0.0.7.9</span> Как удалить контейнер?</h4>
<p>Удалить контейнер можно из окна docker в разделе <code>Containers</code>, нажатием на значок Delete (мусорный ящик) напротив названия контейнера. Либо в <code>PowerShell</code> можно ввести команду:</p>
<pre><code>
&gt; docker rm название_контейнера(или идентификатор)
</code></pre>
<p>После удаления контейнера все данные внутри контейнера будут удалены.</p>
</div>
<div id="как-удалить-образ-контейнера" class="section level4" number="0.0.7.10">
<h4><span class="header-section-number">0.0.7.10</span> Как удалить образ контейнера?</h4>
<p>После остановки контейнера, его можно удалить. Это можно сделать из окна docker в разделе <code>Images</code>. Для этого нужно нажать на значок троеточия напротив названия контейнера, затем выбрать <code>Remove</code>. Либо в <code>PowerShell</code> нужно ввести команду:</p>
<pre><code>
&gt; docker image rm название_образа(или идентификатор) 
</code></pre>
</div>
<div id="как-переносить-файлы-между-компьютером-и-контейнером" class="section level4" number="0.0.7.11">
<h4><span class="header-section-number">0.0.7.11</span> Как переносить файлы между компьютером и контейнером?</h4>
<p>Как уже говорилось, контейнер является полностью изолированной от операционной системы компьютера программой. При запуске контейнера docker создает отдельную файловую систему, и к файлам внутри контейнера невозможно обратиться при помощи стандартного файлового менеджера. Что нужно сделать, чтобы быстро и легко переносить данные из локальной машины в файловую систему компьютера?</p>
<p>Самый простой способ - привязать <em>(bind)</em> к контейнеру какую-нибудь папку на локальной машине. Принцип действия очень простой: при запуске контейнера внутри его файловой системы создается директория, которая привязывается к папке на компьютере. Любые изменения, любые новые файлы, внесенные в этой директории контейнера, автоматически отобразатся в папке на компьютере (и наоборот).</p>
<p>Чтобы привязать папку на компьютере к директории в контейнере (смонтировать Том), нужно добавить к команде <code>docker run</code> параметр <code>-v [путь к папке на компьютере]:[путь к директории контейнера]</code>. Обратите внимание, что путь к папке и путь к директории разделены двоеточием. Однако двоеточие есть в путях к папкам в ОС Windows. Поэтому чтобы вводить в параметр путь к папкам Windows, нужно стандартный адрес папок модифицировать как показано ниже:</p>
<table>
<thead>
<tr class="header">
<th>Адрес папки в Windows</th>
<th>Адрес, который нужно ввести</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>C:\Docker\myContainer\data</td>
<td>//c/Docker/myContainer/data</td>
</tr>
</tbody>
</table>
<p>Обратите внимание:</p>
<ol style="list-style-type: decimal">
<li>Все обратные слэши (\) были заменены на прямые (/)</li>
<li>Название диска (С) написано строчной буквой (с)</li>
<li>Вместо двоеточия после названия диска (C:) пишется двойной слеш перед названием диска (//c)</li>
</ol>
<p>Допустим, вы хотите, чтобы на компьютере с Windows Том располагался в папке “C:\Docker\myContainer\data”. В контейнере, содержащем ядро Linux, этому тому будет соответствовать директория “/data”. команда, монтирующая том будет выглядеть следующим образом:</p>
<pre><code>
&gt; docker run ... -v //c/Docker/myContainer/data:/data ...
</code></pre>
<p>Если вы хотите смонтировать несколько папок, то можно воспользоваться параметром <code>-v</code> несколько раз:</p>
<pre><code>
&gt; docker run ... -v //c/Docker/myContainer/data:/data -v //e/Docker/second_dir:/secondDir ...
</code></pre>
<p>Обратите внимание, что название папки на компьютере и директории в контейнере может не совпадать.</p>
<p>Более продвинутый способ - создать на компьютере <em>Том (Volume)</em>. Тома - это файлы или каталоги, которые смонтированы непосредственно на хосте и не являются частью файловой системы контейнера. По определению, том — это файловая система, которая расположена на хост-машине за пределами контейнеров. Путь к Тому записан в памяти <strong>Docker</strong> в виде переменной, а раздел внутри контейнер может быть привязан к этой переменной, так что</p>
<p>Создать том можно двумя способами:
1. В разделе Volumes программы <strong>Docker Desktop</strong> нажать кнопку <em>Create</em> (правый верхний угол) и ввести какое-нибудь название.</p>
<ol start="2" style="list-style-type: decimal">
<li>В терминале (Cmd или PowerShell) ввести команду</li>
</ol>
<pre><code>
&gt; docker volume create название_тома
</code></pre>
<p>Вы можете найти эту папку при помощи файлового менеджера. Путь к папке, в которой лежат Томы в Windows 11 находится по адресу <code>\\wsl.localhost\docker-desktop-data\data\docker\volumes</code>. Его можно ввести в адресную строку проводника:</p>
<div class="figure">
<img src="/Programs/Docker.files/Volume.png?width=20pc" alt="" />
<p class="caption">Volume</p>
</div>
<p>На скриншоте выше показно, как это может выглядеть. Обратите внимание, в проводнике <strong>Explorer</strong> в левой части экрана располагается панель быстрого доступа, где можно увидеть смонтированные при помощи WSL2 разделы <code>docker-desktop</code> и <code>docker-desktop-data</code>, которые появляются после установки <strong>Docker Desktop</strong>. В разделе <code>docker-desktop-data</code> - в указанной выше директории - и хранятся тома. На скриншоте показано, что помимо служебных файлов в этой диркетории лежит папка <code>my_vol</code>. Это название универсального тома, который был создан командой <code>docker volume create my_vol</code>. В этой папке лежит несколько служебных папок, а также папка <code>_data</code>. Собственно, содержимое последней папки и будет синхронизироваться с разделами контейнеров.</p>
<p>Для примера, в эту папку были скопированы несколько файлов: текстовый файл <code>1.txt</code>, HiC карта <code>dixon.mcool</code>, а также изображение <code>program.png</code>. После копирования, появилось еще несколько служебных файлов, которые для нас не важны. Просмотреть содержимое тома <code>my_vol</code> можено в разделе <em>Volumes</em> в <strong>Docker Desktop</strong>, если нажать на название тома и выбрать вкладку <code>DATA</code>.</p>
<p><img src="/Programs/Docker.files/Volume2.png?width=20pc" alt="Volume1" />
<img src="/Programs/Docker.files/Volume1.png?width=20pc" alt="Volume2" />
<img src="/Programs/Docker.files/Volume3.png?width=20pc" alt="Volume3" /></p>
<p>После создания тома его можно привязывать к нескольким контейнерам, просто указав название тома перед названием директории в контейнере в параметре <code>-v</code></p>
<pre><code>
&gt; docker run ... -v my_vol:/data ...
</code></pre>
<p>Удалить том можно в разделе <em>Volumes</em> в <strong>Docker Desktop</strong> (значок корзины) либо в терминале при помощи команды</p>
<pre><code>
&gt; docker volume rm название_тома
</code></pre>
<p>Узнать список всех томов на компьютере можно в разделе <em>Volumes</em> в <strong>Docker Desktop</strong> либо в терминале при помощи команды</p>
<pre><code>
&gt; docker volume ls
</code></pre>
</div>
<div id="как-копировать-файлы-в-контейнер-и-из-него" class="section level4" number="0.0.7.12">
<h4><span class="header-section-number">0.0.7.12</span> Как копировать файлы в контейнер и из него?</h4>
<p>Если вы хотите напрямую скопировать файлы из вашей хост-системы в контейнер, вы должны использовать команду <code>docker cp</code> к терминале (<strong>Cmd</strong> или <strong>PowerShell</strong>), например:</p>
<pre><code>
&gt; docker cp путь_к_файлу_на_компьютере название_контейнера:путь_назначения_в_контейнере
</code></pre>
<p>Это работает и в обратную сторону:</p>
<pre><code>
&gt; docker cp название_контейнера:путь_к_файлу_в_контейнере путь_назначения_на_компьютере
</code></pre>
</div>
</div>
<div id="применение-на-практике" class="section level3" number="0.0.8">
<h3><span class="header-section-number">0.0.8</span> Применение на практике</h3>
<p>Как уже говорилось, программа bowtie2 написана под ОС Linux. Но при помощи Docker ее можно очень быстро запустить на компьютере. Ниже приведен совершенно стандартный алгоритм выравнивания fastq-файлов при помощи bowtie2 в Docker.</p>
<p>Для данного примера из github-репозитория <a href="https://github.com/wzthu/Rbowtie2/tree/master/inst/extdata/bt2">Rbowtie2</a> были загружены экземпляры fastq-файлов (<code>reads_1.fastq</code> + <code>reads_2.fastq</code>) и fasta-референс генома фага лямбда (<code>lambda_virus.fa</code>). Создатели библитеки Rbowtie2 (для языка программирования R) предоставили эти данные для тестирования своей библиотеки на компьютере пользователей. Мы могли бы взять совершенно другие данные, так как это не принципиально. Эти файлы были загружены в директорию <code>C:\\Docker_control\\Bowtie2_example</code> со следующей структурой:</p>
<pre><code>C:\Docker_control\Bowtie2_example\
    refs\
        lambda_virus.fa
    reads\
        reads_1.fastq
        reads_2.fastq</code></pre>
<p>Первое, что мы должны сделать - это выбрать образ для контейнера. В <strong>Docker Hub</strong> я выбрал репозиторий <code>biocontainers/bowtie2</code>, поскольку из него было больше всего скачиваний. После просмотра тэгов в репозитории я обнаружил, что тэг “latest” отсутствует. Поэтому указание <code>biocontainers/bowtie2</code> для скачивания образа приведет к ошибке. Поэтому я вручную выбрал тег <code>v2.3.4.3-1-deb_cv2</code>, поскольку у него был небольшой объем.</p>
<p>Скачал образ заранее:</p>
<pre><code>docker pull biocontainers/bowtie2:v2.3.4.3-1-deb_cv2</code></pre>
<p>Теперь нужно проиндексировать FASTA-файл с референсным геномом вируса при помощи <a href="https://epigenlabprotocols.netlify.app/programs/bowtie2/#индексирование-генома-с-помощью-bowtie2-build">bowtie2-build</a>.</p>
<pre><code>docker run --rm -v //c/Docker_control/Bowtie2_example/refs/:/data/ -w /data biocontainers/bowtie2:v2.3.4.3-1-deb_cv2 bowtie2-build lambda_virus.fa lv</code></pre>
<p>С помощью последней команды сделали следующее:
1. Запустили оболочку Linux внутри контейнера и привязали там директорию <code>/data</code> к папке <code>C:\\Docker_control\\Bowtie2_example\\</code>
2. Установили рабочую директорию <code>/data/refs/</code> при помощи параметра <code>-w /data/</code>. Это сделано для простоты.
3. Запустили внутри контейнера программу <code>bowtie2-build</code> с fasta-файлом на входе и оутпутом в папке <code>/data/</code>.
4. Удалили контейнер сразу после завершения <code>bowtie2-build</code>.</p>
<p>Индексы получились.</p>
<pre><code>    refs\
        lambda_virus.fa
        lv.1.bt2&quot;
        lv.2.bt2&quot;
        lv.3.bt2&quot;
        lv.4.bt2&quot;
        lv.rev.1.bt2&quot;
        lv.rev.2.bt2&quot;</code></pre>
<p>Теперь выравниваю</p>
<pre><code>docker run --rm -v //c/Docker_control/Bowtie2_example/:/data/ -w /data biocontainers/bowtie2:v2.3.4.3-1-deb_cv2 bowtie2 -x refs/lv -1 reads/reads_1.fastq -2 reads/reads_2.fastq -S lv_align.sam &quot;2&gt;align.summary.txt&quot;</code></pre>
<p>Обратите внимание, чтобы вывести логи выравнивания из канала <strong>STDERR</strong> (см. документацию <a href="https://epigenlabprotocols.netlify.app/programs/bowtie2/#сводка-по-выравниванию">Bowtei2</a>) в файл align.summary.txt, потребовалось оградить запись <code>2&gt;align.summary.txt</code> двойными скобками, так как командная строка PowerShell не понимает знак “&gt;”.</p>
<p>Мы можем убедиться, что выравнивание прошло успешно, открыв логи выравнивания, которые появились в файле <code>C:\Docker_control\Bowtie2_example\align.summary.txt</code></p>
<pre><code>1000 reads; of these:
  1000 (100.00%) were paired; of these:
    82 (8.20%) aligned concordantly 0 times
    918 (91.80%) aligned concordantly exactly 1 time
    0 (0.00%) aligned concordantly &gt;1 times
    ----
    82 pairs aligned concordantly 0 times; of these:
      5 (6.10%) aligned discordantly 1 time
    ----
    77 pairs aligned 0 times concordantly or discordantly; of these:
      154 mates make up the pairs; of these:
        100 (64.94%) aligned 0 times
        54 (35.06%) aligned exactly 1 time
        0 (0.00%) aligned &gt;1 times
95.00% overall alignment rate</code></pre>
<p>Sam-файл с выравниванием располагается в по адресу <code>C:\Docker_control\Bowtie2_example\lv-align.sam</code></p>
<p>Стоит обратить внимание, что то же самое можно сделать, запустив интерактивный терминал внутри контейнера:</p>
<pre><code>&gt;docker run -it --rm -v //c/Docker_control/Bowtie2_example/:/data/ biocontainers/bowtie2:v2.3.4.3-1-deb_cv2

biodocker@f2e8661dab5d# cd /data/refs
biodocker@f2e8661dab5d# $bowtie2-build lambda_virus.fa lv
biodocker@f2e8661dab5d# $cd /data
biodocker@f2e8661dab5d# $bowtie2 -x refs/lv -1 reads/reads_1.fastq -2 reads/reads_2.fastq -S lv_align.sam 2&gt;align.summary.txt
biodocker@f2e8661dab5d# exit

&gt;</code></pre>
<p>Обратите внимание, что последняя команда, введенная в терминал была <code>exit</code>. Она позволяет покинуть терминал в Linux-системе.</p>
</div>
<div id="литература" class="section level3" number="0.0.9">
<h3><span class="header-section-number">0.0.9</span> Литература</h3>
<p><a href="https://drive.google.com/file/d/1BYH8Lh46ZWtInXYYRncr4oqjXhMMHa8n/view?usp=sharing">Милл Иан, Сейерс Эйдан Хобсон - Docker на практике (2020)</a></p>
<p><a href="https://drive.google.com/file/d/136mEKfg2tM3alMeqSdD4vCt9iqheBSTb/view?usp=sharing">Эдриен Моуэт - Использование Docker (2017)</a></p>
</div>
<div id="документация" class="section level3" number="0.0.10">
<h3><span class="header-section-number">0.0.10</span> Документация</h3>
<p><a href="https://docs.docker.com/">Официальная документация</a></p>
<p><a href="https://dker.ru/docs/">Русская версия документации</a></p>
<p><a href="https://youtube.com/playlist?list=PLD5U-C5KK50XMCBkY0U-NLzglcRHzOwAg">Видеоуроки</a></p>
<p><a href="https://tretyakov.net/post/ustanovit-docker-na-windows-10-wsl2/">Инструкция по установке на Windows с WSL2</a></p>
<p><a href="https://ip-calculator.ru/blog/ask/ustanovka-docker-na-windows-10-home/">Еще одна инструкция по установке на Windows с WSL2</a></p>
</div>
